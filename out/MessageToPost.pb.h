// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageToPost.proto

#ifndef PROTOBUF_MessageToPost_2eproto__INCLUDED
#define PROTOBUF_MessageToPost_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MessageToPost_2eproto();
void protobuf_AssignDesc_MessageToPost_2eproto();
void protobuf_ShutdownFile_MessageToPost_2eproto();

class MessageToPost;
class XmlDocumentAttachment;
class SignedContent;
class NonformalizedAttachment;
class BasicDocumentAttachment;
class TrustConnectionRequestAttachment;
class StructuredDataAttachment;
class PriceListAttachment;
class ReconciliationActAttachment;
class ContractAttachment;
class Torg13Attachment;
class ServiceDetailsAttachment;
class DocumentId;

// ===================================================================

class MessageToPost : public ::google::protobuf::Message {
 public:
  MessageToPost();
  virtual ~MessageToPost();

  MessageToPost(const MessageToPost& from);

  inline MessageToPost& operator=(const MessageToPost& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageToPost& default_instance();

  void Swap(MessageToPost* other);

  // implements Message ----------------------------------------------

  MessageToPost* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageToPost& from);
  void MergeFrom(const MessageToPost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string FromBoxId = 1;
  inline bool has_fromboxid() const;
  inline void clear_fromboxid();
  static const int kFromBoxIdFieldNumber = 1;
  inline const ::std::string& fromboxid() const;
  inline void set_fromboxid(const ::std::string& value);
  inline void set_fromboxid(const char* value);
  inline void set_fromboxid(const char* value, size_t size);
  inline ::std::string* mutable_fromboxid();
  inline ::std::string* release_fromboxid();
  inline void set_allocated_fromboxid(::std::string* fromboxid);

  // optional string ToBoxId = 2;
  inline bool has_toboxid() const;
  inline void clear_toboxid();
  static const int kToBoxIdFieldNumber = 2;
  inline const ::std::string& toboxid() const;
  inline void set_toboxid(const ::std::string& value);
  inline void set_toboxid(const char* value);
  inline void set_toboxid(const char* value, size_t size);
  inline ::std::string* mutable_toboxid();
  inline ::std::string* release_toboxid();
  inline void set_allocated_toboxid(::std::string* toboxid);

  // repeated .XmlDocumentAttachment Invoices = 3;
  inline int invoices_size() const;
  inline void clear_invoices();
  static const int kInvoicesFieldNumber = 3;
  inline const ::XmlDocumentAttachment& invoices(int index) const;
  inline ::XmlDocumentAttachment* mutable_invoices(int index);
  inline ::XmlDocumentAttachment* add_invoices();
  inline const ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >&
      invoices() const;
  inline ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >*
      mutable_invoices();

  // repeated .NonformalizedAttachment NonformalizedDocuments = 4;
  inline int nonformalizeddocuments_size() const;
  inline void clear_nonformalizeddocuments();
  static const int kNonformalizedDocumentsFieldNumber = 4;
  inline const ::NonformalizedAttachment& nonformalizeddocuments(int index) const;
  inline ::NonformalizedAttachment* mutable_nonformalizeddocuments(int index);
  inline ::NonformalizedAttachment* add_nonformalizeddocuments();
  inline const ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >&
      nonformalizeddocuments() const;
  inline ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >*
      mutable_nonformalizeddocuments();

  // repeated .BasicDocumentAttachment Torg12Documents = 5;
  inline int torg12documents_size() const;
  inline void clear_torg12documents();
  static const int kTorg12DocumentsFieldNumber = 5;
  inline const ::BasicDocumentAttachment& torg12documents(int index) const;
  inline ::BasicDocumentAttachment* mutable_torg12documents(int index);
  inline ::BasicDocumentAttachment* add_torg12documents();
  inline const ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >&
      torg12documents() const;
  inline ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >*
      mutable_torg12documents();

  // optional .TrustConnectionRequestAttachment TrustConnectionRequest = 6;
  inline bool has_trustconnectionrequest() const;
  inline void clear_trustconnectionrequest();
  static const int kTrustConnectionRequestFieldNumber = 6;
  inline const ::TrustConnectionRequestAttachment& trustconnectionrequest() const;
  inline ::TrustConnectionRequestAttachment* mutable_trustconnectionrequest();
  inline ::TrustConnectionRequestAttachment* release_trustconnectionrequest();
  inline void set_allocated_trustconnectionrequest(::TrustConnectionRequestAttachment* trustconnectionrequest);

  // repeated .BasicDocumentAttachment AcceptanceCertificates = 7;
  inline int acceptancecertificates_size() const;
  inline void clear_acceptancecertificates();
  static const int kAcceptanceCertificatesFieldNumber = 7;
  inline const ::BasicDocumentAttachment& acceptancecertificates(int index) const;
  inline ::BasicDocumentAttachment* mutable_acceptancecertificates(int index);
  inline ::BasicDocumentAttachment* add_acceptancecertificates();
  inline const ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >&
      acceptancecertificates() const;
  inline ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >*
      mutable_acceptancecertificates();

  // repeated .StructuredDataAttachment StructuredDataAttachments = 8;
  inline int structureddataattachments_size() const;
  inline void clear_structureddataattachments();
  static const int kStructuredDataAttachmentsFieldNumber = 8;
  inline const ::StructuredDataAttachment& structureddataattachments(int index) const;
  inline ::StructuredDataAttachment* mutable_structureddataattachments(int index);
  inline ::StructuredDataAttachment* add_structureddataattachments();
  inline const ::google::protobuf::RepeatedPtrField< ::StructuredDataAttachment >&
      structureddataattachments() const;
  inline ::google::protobuf::RepeatedPtrField< ::StructuredDataAttachment >*
      mutable_structureddataattachments();

  // repeated .BasicDocumentAttachment ProformaInvoices = 9;
  inline int proformainvoices_size() const;
  inline void clear_proformainvoices();
  static const int kProformaInvoicesFieldNumber = 9;
  inline const ::BasicDocumentAttachment& proformainvoices(int index) const;
  inline ::BasicDocumentAttachment* mutable_proformainvoices(int index);
  inline ::BasicDocumentAttachment* add_proformainvoices();
  inline const ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >&
      proformainvoices() const;
  inline ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >*
      mutable_proformainvoices();

  // repeated .XmlDocumentAttachment XmlTorg12SellerTitles = 10;
  inline int xmltorg12sellertitles_size() const;
  inline void clear_xmltorg12sellertitles();
  static const int kXmlTorg12SellerTitlesFieldNumber = 10;
  inline const ::XmlDocumentAttachment& xmltorg12sellertitles(int index) const;
  inline ::XmlDocumentAttachment* mutable_xmltorg12sellertitles(int index);
  inline ::XmlDocumentAttachment* add_xmltorg12sellertitles();
  inline const ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >&
      xmltorg12sellertitles() const;
  inline ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >*
      mutable_xmltorg12sellertitles();

  // repeated .XmlDocumentAttachment XmlAcceptanceCertificateSellerTitles = 11;
  inline int xmlacceptancecertificatesellertitles_size() const;
  inline void clear_xmlacceptancecertificatesellertitles();
  static const int kXmlAcceptanceCertificateSellerTitlesFieldNumber = 11;
  inline const ::XmlDocumentAttachment& xmlacceptancecertificatesellertitles(int index) const;
  inline ::XmlDocumentAttachment* mutable_xmlacceptancecertificatesellertitles(int index);
  inline ::XmlDocumentAttachment* add_xmlacceptancecertificatesellertitles();
  inline const ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >&
      xmlacceptancecertificatesellertitles() const;
  inline ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >*
      mutable_xmlacceptancecertificatesellertitles();

  // optional string ToDepartmentId = 12;
  inline bool has_todepartmentid() const;
  inline void clear_todepartmentid();
  static const int kToDepartmentIdFieldNumber = 12;
  inline const ::std::string& todepartmentid() const;
  inline void set_todepartmentid(const ::std::string& value);
  inline void set_todepartmentid(const char* value);
  inline void set_todepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_todepartmentid();
  inline ::std::string* release_todepartmentid();
  inline void set_allocated_todepartmentid(::std::string* todepartmentid);

  // optional bool IsDraft = 13 [default = false];
  inline bool has_isdraft() const;
  inline void clear_isdraft();
  static const int kIsDraftFieldNumber = 13;
  inline bool isdraft() const;
  inline void set_isdraft(bool value);

  // optional bool LockDraft = 14 [default = false];
  inline bool has_lockdraft() const;
  inline void clear_lockdraft();
  static const int kLockDraftFieldNumber = 14;
  inline bool lockdraft() const;
  inline void set_lockdraft(bool value);

  // optional bool StrictDraftValidation = 15 [default = true];
  inline bool has_strictdraftvalidation() const;
  inline void clear_strictdraftvalidation();
  static const int kStrictDraftValidationFieldNumber = 15;
  inline bool strictdraftvalidation() const;
  inline void set_strictdraftvalidation(bool value);

  // optional bool IsInternal = 16 [default = false];
  inline bool has_isinternal() const;
  inline void clear_isinternal();
  static const int kIsInternalFieldNumber = 16;
  inline bool isinternal() const;
  inline void set_isinternal(bool value);

  // optional string FromDepartmentId = 17;
  inline bool has_fromdepartmentid() const;
  inline void clear_fromdepartmentid();
  static const int kFromDepartmentIdFieldNumber = 17;
  inline const ::std::string& fromdepartmentid() const;
  inline void set_fromdepartmentid(const ::std::string& value);
  inline void set_fromdepartmentid(const char* value);
  inline void set_fromdepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_fromdepartmentid();
  inline ::std::string* release_fromdepartmentid();
  inline void set_allocated_fromdepartmentid(::std::string* fromdepartmentid);

  // optional bool DelaySend = 18 [default = false];
  inline bool has_delaysend() const;
  inline void clear_delaysend();
  static const int kDelaySendFieldNumber = 18;
  inline bool delaysend() const;
  inline void set_delaysend(bool value);

  // repeated .PriceListAttachment PriceLists = 19;
  inline int pricelists_size() const;
  inline void clear_pricelists();
  static const int kPriceListsFieldNumber = 19;
  inline const ::PriceListAttachment& pricelists(int index) const;
  inline ::PriceListAttachment* mutable_pricelists(int index);
  inline ::PriceListAttachment* add_pricelists();
  inline const ::google::protobuf::RepeatedPtrField< ::PriceListAttachment >&
      pricelists() const;
  inline ::google::protobuf::RepeatedPtrField< ::PriceListAttachment >*
      mutable_pricelists();

  // repeated .NonformalizedAttachment PriceListAgreements = 20;
  inline int pricelistagreements_size() const;
  inline void clear_pricelistagreements();
  static const int kPriceListAgreementsFieldNumber = 20;
  inline const ::NonformalizedAttachment& pricelistagreements(int index) const;
  inline ::NonformalizedAttachment* mutable_pricelistagreements(int index);
  inline ::NonformalizedAttachment* add_pricelistagreements();
  inline const ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >&
      pricelistagreements() const;
  inline ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >*
      mutable_pricelistagreements();

  // repeated .NonformalizedAttachment CertificateRegistries = 21;
  inline int certificateregistries_size() const;
  inline void clear_certificateregistries();
  static const int kCertificateRegistriesFieldNumber = 21;
  inline const ::NonformalizedAttachment& certificateregistries(int index) const;
  inline ::NonformalizedAttachment* mutable_certificateregistries(int index);
  inline ::NonformalizedAttachment* add_certificateregistries();
  inline const ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >&
      certificateregistries() const;
  inline ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >*
      mutable_certificateregistries();

  // repeated .ReconciliationActAttachment ReconciliationActs = 22;
  inline int reconciliationacts_size() const;
  inline void clear_reconciliationacts();
  static const int kReconciliationActsFieldNumber = 22;
  inline const ::ReconciliationActAttachment& reconciliationacts(int index) const;
  inline ::ReconciliationActAttachment* mutable_reconciliationacts(int index);
  inline ::ReconciliationActAttachment* add_reconciliationacts();
  inline const ::google::protobuf::RepeatedPtrField< ::ReconciliationActAttachment >&
      reconciliationacts() const;
  inline ::google::protobuf::RepeatedPtrField< ::ReconciliationActAttachment >*
      mutable_reconciliationacts();

  // repeated .ContractAttachment Contracts = 23;
  inline int contracts_size() const;
  inline void clear_contracts();
  static const int kContractsFieldNumber = 23;
  inline const ::ContractAttachment& contracts(int index) const;
  inline ::ContractAttachment* mutable_contracts(int index);
  inline ::ContractAttachment* add_contracts();
  inline const ::google::protobuf::RepeatedPtrField< ::ContractAttachment >&
      contracts() const;
  inline ::google::protobuf::RepeatedPtrField< ::ContractAttachment >*
      mutable_contracts();

  // repeated .Torg13Attachment Torg13Documents = 24;
  inline int torg13documents_size() const;
  inline void clear_torg13documents();
  static const int kTorg13DocumentsFieldNumber = 24;
  inline const ::Torg13Attachment& torg13documents(int index) const;
  inline ::Torg13Attachment* mutable_torg13documents(int index);
  inline ::Torg13Attachment* add_torg13documents();
  inline const ::google::protobuf::RepeatedPtrField< ::Torg13Attachment >&
      torg13documents() const;
  inline ::google::protobuf::RepeatedPtrField< ::Torg13Attachment >*
      mutable_torg13documents();

  // repeated .ServiceDetailsAttachment ServiceDetailsDocuments = 25;
  inline int servicedetailsdocuments_size() const;
  inline void clear_servicedetailsdocuments();
  static const int kServiceDetailsDocumentsFieldNumber = 25;
  inline const ::ServiceDetailsAttachment& servicedetailsdocuments(int index) const;
  inline ::ServiceDetailsAttachment* mutable_servicedetailsdocuments(int index);
  inline ::ServiceDetailsAttachment* add_servicedetailsdocuments();
  inline const ::google::protobuf::RepeatedPtrField< ::ServiceDetailsAttachment >&
      servicedetailsdocuments() const;
  inline ::google::protobuf::RepeatedPtrField< ::ServiceDetailsAttachment >*
      mutable_servicedetailsdocuments();

  // @@protoc_insertion_point(class_scope:MessageToPost)
 private:
  inline void set_has_fromboxid();
  inline void clear_has_fromboxid();
  inline void set_has_toboxid();
  inline void clear_has_toboxid();
  inline void set_has_trustconnectionrequest();
  inline void clear_has_trustconnectionrequest();
  inline void set_has_todepartmentid();
  inline void clear_has_todepartmentid();
  inline void set_has_isdraft();
  inline void clear_has_isdraft();
  inline void set_has_lockdraft();
  inline void clear_has_lockdraft();
  inline void set_has_strictdraftvalidation();
  inline void clear_has_strictdraftvalidation();
  inline void set_has_isinternal();
  inline void clear_has_isinternal();
  inline void set_has_fromdepartmentid();
  inline void clear_has_fromdepartmentid();
  inline void set_has_delaysend();
  inline void clear_has_delaysend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fromboxid_;
  ::std::string* toboxid_;
  ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment > invoices_;
  ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment > nonformalizeddocuments_;
  ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment > torg12documents_;
  ::TrustConnectionRequestAttachment* trustconnectionrequest_;
  ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment > acceptancecertificates_;
  ::google::protobuf::RepeatedPtrField< ::StructuredDataAttachment > structureddataattachments_;
  ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment > proformainvoices_;
  ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment > xmltorg12sellertitles_;
  ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment > xmlacceptancecertificatesellertitles_;
  ::std::string* todepartmentid_;
  bool isdraft_;
  bool lockdraft_;
  bool strictdraftvalidation_;
  bool isinternal_;
  bool delaysend_;
  ::std::string* fromdepartmentid_;
  ::google::protobuf::RepeatedPtrField< ::PriceListAttachment > pricelists_;
  ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment > pricelistagreements_;
  ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment > certificateregistries_;
  ::google::protobuf::RepeatedPtrField< ::ReconciliationActAttachment > reconciliationacts_;
  ::google::protobuf::RepeatedPtrField< ::ContractAttachment > contracts_;
  ::google::protobuf::RepeatedPtrField< ::Torg13Attachment > torg13documents_;
  ::google::protobuf::RepeatedPtrField< ::ServiceDetailsAttachment > servicedetailsdocuments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static MessageToPost* default_instance_;
};
// -------------------------------------------------------------------

class XmlDocumentAttachment : public ::google::protobuf::Message {
 public:
  XmlDocumentAttachment();
  virtual ~XmlDocumentAttachment();

  XmlDocumentAttachment(const XmlDocumentAttachment& from);

  inline XmlDocumentAttachment& operator=(const XmlDocumentAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XmlDocumentAttachment& default_instance();

  void Swap(XmlDocumentAttachment* other);

  // implements Message ----------------------------------------------

  XmlDocumentAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XmlDocumentAttachment& from);
  void MergeFrom(const XmlDocumentAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::SignedContent& signedcontent() const;
  inline ::SignedContent* mutable_signedcontent();
  inline ::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::SignedContent* signedcontent);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::DocumentId& initialdocumentids(int index) const;
  inline ::DocumentId* mutable_initialdocumentids(int index);
  inline ::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_initialdocumentids();

  // repeated .DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::DocumentId& subordinatedocumentids(int index) const;
  inline ::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string CustomDocumentId = 6;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 6;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // @@protoc_insertion_point(class_scope:XmlDocumentAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SignedContent* signedcontent_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > subordinatedocumentids_;
  ::std::string* customdocumentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static XmlDocumentAttachment* default_instance_;
};
// -------------------------------------------------------------------

class SignedContent : public ::google::protobuf::Message {
 public:
  SignedContent();
  virtual ~SignedContent();

  SignedContent(const SignedContent& from);

  inline SignedContent& operator=(const SignedContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedContent& default_instance();

  void Swap(SignedContent* other);

  // implements Message ----------------------------------------------

  SignedContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedContent& from);
  void MergeFrom(const SignedContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes Content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional bytes Signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bool SignByAttorney = 3 [default = false];
  inline bool has_signbyattorney() const;
  inline void clear_signbyattorney();
  static const int kSignByAttorneyFieldNumber = 3;
  inline bool signbyattorney() const;
  inline void set_signbyattorney(bool value);

  // optional string NameOnShelf = 4;
  inline bool has_nameonshelf() const;
  inline void clear_nameonshelf();
  static const int kNameOnShelfFieldNumber = 4;
  inline const ::std::string& nameonshelf() const;
  inline void set_nameonshelf(const ::std::string& value);
  inline void set_nameonshelf(const char* value);
  inline void set_nameonshelf(const char* value, size_t size);
  inline ::std::string* mutable_nameonshelf();
  inline ::std::string* release_nameonshelf();
  inline void set_allocated_nameonshelf(::std::string* nameonshelf);

  // optional bool SignWithTestSignature = 5 [default = false];
  inline bool has_signwithtestsignature() const;
  inline void clear_signwithtestsignature();
  static const int kSignWithTestSignatureFieldNumber = 5;
  inline bool signwithtestsignature() const;
  inline void set_signwithtestsignature(bool value);

  // @@protoc_insertion_point(class_scope:SignedContent)
 private:
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_signbyattorney();
  inline void clear_has_signbyattorney();
  inline void set_has_nameonshelf();
  inline void clear_has_nameonshelf();
  inline void set_has_signwithtestsignature();
  inline void clear_has_signwithtestsignature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::std::string* signature_;
  ::std::string* nameonshelf_;
  bool signbyattorney_;
  bool signwithtestsignature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static SignedContent* default_instance_;
};
// -------------------------------------------------------------------

class NonformalizedAttachment : public ::google::protobuf::Message {
 public:
  NonformalizedAttachment();
  virtual ~NonformalizedAttachment();

  NonformalizedAttachment(const NonformalizedAttachment& from);

  inline NonformalizedAttachment& operator=(const NonformalizedAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NonformalizedAttachment& default_instance();

  void Swap(NonformalizedAttachment* other);

  // implements Message ----------------------------------------------

  NonformalizedAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NonformalizedAttachment& from);
  void MergeFrom(const NonformalizedAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::SignedContent& signedcontent() const;
  inline ::SignedContent* mutable_signedcontent();
  inline ::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional bool NeedRecipientSignature = 4 [default = false];
  inline bool has_needrecipientsignature() const;
  inline void clear_needrecipientsignature();
  static const int kNeedRecipientSignatureFieldNumber = 4;
  inline bool needrecipientsignature() const;
  inline void set_needrecipientsignature(bool value);

  // repeated .DocumentId InitialDocumentIds = 5;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 5;
  inline const ::DocumentId& initialdocumentids(int index) const;
  inline ::DocumentId* mutable_initialdocumentids(int index);
  inline ::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_initialdocumentids();

  // repeated .DocumentId SubordinateDocumentIds = 6;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 6;
  inline const ::DocumentId& subordinatedocumentids(int index) const;
  inline ::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string DocumentDate = 7;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 7;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // optional string DocumentNumber = 8;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 8;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // optional string CustomDocumentId = 9;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 9;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // @@protoc_insertion_point(class_scope:NonformalizedAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_needrecipientsignature();
  inline void clear_has_needrecipientsignature();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > subordinatedocumentids_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* customdocumentid_;
  bool needrecipientsignature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static NonformalizedAttachment* default_instance_;
};
// -------------------------------------------------------------------

class BasicDocumentAttachment : public ::google::protobuf::Message {
 public:
  BasicDocumentAttachment();
  virtual ~BasicDocumentAttachment();

  BasicDocumentAttachment(const BasicDocumentAttachment& from);

  inline BasicDocumentAttachment& operator=(const BasicDocumentAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicDocumentAttachment& default_instance();

  void Swap(BasicDocumentAttachment* other);

  // implements Message ----------------------------------------------

  BasicDocumentAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasicDocumentAttachment& from);
  void MergeFrom(const BasicDocumentAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::SignedContent& signedcontent() const;
  inline ::SignedContent* mutable_signedcontent();
  inline ::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::DocumentId& initialdocumentids(int index) const;
  inline ::DocumentId* mutable_initialdocumentids(int index);
  inline ::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_initialdocumentids();

  // repeated .DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::DocumentId& subordinatedocumentids(int index) const;
  inline ::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_subordinatedocumentids();

  // required string DocumentDate = 6;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 6;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 7;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 7;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // required string Total = 8;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 8;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional string CustomDocumentId = 9;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 9;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional string Vat = 10;
  inline bool has_vat() const;
  inline void clear_vat();
  static const int kVatFieldNumber = 10;
  inline const ::std::string& vat() const;
  inline void set_vat(const ::std::string& value);
  inline void set_vat(const char* value);
  inline void set_vat(const char* value, size_t size);
  inline ::std::string* mutable_vat();
  inline ::std::string* release_vat();
  inline void set_allocated_vat(::std::string* vat);

  // optional string Grounds = 11;
  inline bool has_grounds() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 11;
  inline const ::std::string& grounds() const;
  inline void set_grounds(const ::std::string& value);
  inline void set_grounds(const char* value);
  inline void set_grounds(const char* value, size_t size);
  inline ::std::string* mutable_grounds();
  inline ::std::string* release_grounds();
  inline void set_allocated_grounds(::std::string* grounds);

  // @@protoc_insertion_point(class_scope:BasicDocumentAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_vat();
  inline void clear_has_vat();
  inline void set_has_grounds();
  inline void clear_has_grounds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > subordinatedocumentids_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* total_;
  ::std::string* customdocumentid_;
  ::std::string* vat_;
  ::std::string* grounds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static BasicDocumentAttachment* default_instance_;
};
// -------------------------------------------------------------------

class TrustConnectionRequestAttachment : public ::google::protobuf::Message {
 public:
  TrustConnectionRequestAttachment();
  virtual ~TrustConnectionRequestAttachment();

  TrustConnectionRequestAttachment(const TrustConnectionRequestAttachment& from);

  inline TrustConnectionRequestAttachment& operator=(const TrustConnectionRequestAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrustConnectionRequestAttachment& default_instance();

  void Swap(TrustConnectionRequestAttachment* other);

  // implements Message ----------------------------------------------

  TrustConnectionRequestAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrustConnectionRequestAttachment& from);
  void MergeFrom(const TrustConnectionRequestAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::SignedContent& signedcontent() const;
  inline ::SignedContent* mutable_signedcontent();
  inline ::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // optional string CustomDocumentId = 4;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 4;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // @@protoc_insertion_point(class_scope:TrustConnectionRequestAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::std::string* customdocumentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static TrustConnectionRequestAttachment* default_instance_;
};
// -------------------------------------------------------------------

class StructuredDataAttachment : public ::google::protobuf::Message {
 public:
  StructuredDataAttachment();
  virtual ~StructuredDataAttachment();

  StructuredDataAttachment(const StructuredDataAttachment& from);

  inline StructuredDataAttachment& operator=(const StructuredDataAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StructuredDataAttachment& default_instance();

  void Swap(StructuredDataAttachment* other);

  // implements Message ----------------------------------------------

  StructuredDataAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StructuredDataAttachment& from);
  void MergeFrom(const StructuredDataAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes Content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required string DocumentId = 3;
  inline bool has_documentid() const;
  inline void clear_documentid();
  static const int kDocumentIdFieldNumber = 3;
  inline const ::std::string& documentid() const;
  inline void set_documentid(const ::std::string& value);
  inline void set_documentid(const char* value);
  inline void set_documentid(const char* value, size_t size);
  inline ::std::string* mutable_documentid();
  inline ::std::string* release_documentid();
  inline void set_allocated_documentid(::std::string* documentid);

  // @@protoc_insertion_point(class_scope:StructuredDataAttachment)
 private:
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_documentid();
  inline void clear_has_documentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::std::string* filename_;
  ::std::string* documentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static StructuredDataAttachment* default_instance_;
};
// -------------------------------------------------------------------

class PriceListAttachment : public ::google::protobuf::Message {
 public:
  PriceListAttachment();
  virtual ~PriceListAttachment();

  PriceListAttachment(const PriceListAttachment& from);

  inline PriceListAttachment& operator=(const PriceListAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceListAttachment& default_instance();

  void Swap(PriceListAttachment* other);

  // implements Message ----------------------------------------------

  PriceListAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PriceListAttachment& from);
  void MergeFrom(const PriceListAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::SignedContent& signedcontent() const;
  inline ::SignedContent* mutable_signedcontent();
  inline ::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::DocumentId& initialdocumentids(int index) const;
  inline ::DocumentId* mutable_initialdocumentids(int index);
  inline ::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_initialdocumentids();

  // repeated .DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::DocumentId& subordinatedocumentids(int index) const;
  inline ::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string CustomDocumentId = 6;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 6;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // required string DocumentDate = 7;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 7;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 8;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 8;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // required string PriceListEffectiveDate = 9;
  inline bool has_pricelisteffectivedate() const;
  inline void clear_pricelisteffectivedate();
  static const int kPriceListEffectiveDateFieldNumber = 9;
  inline const ::std::string& pricelisteffectivedate() const;
  inline void set_pricelisteffectivedate(const ::std::string& value);
  inline void set_pricelisteffectivedate(const char* value);
  inline void set_pricelisteffectivedate(const char* value, size_t size);
  inline ::std::string* mutable_pricelisteffectivedate();
  inline ::std::string* release_pricelisteffectivedate();
  inline void set_allocated_pricelisteffectivedate(::std::string* pricelisteffectivedate);

  // required string ContractDocumentDate = 10;
  inline bool has_contractdocumentdate() const;
  inline void clear_contractdocumentdate();
  static const int kContractDocumentDateFieldNumber = 10;
  inline const ::std::string& contractdocumentdate() const;
  inline void set_contractdocumentdate(const ::std::string& value);
  inline void set_contractdocumentdate(const char* value);
  inline void set_contractdocumentdate(const char* value, size_t size);
  inline ::std::string* mutable_contractdocumentdate();
  inline ::std::string* release_contractdocumentdate();
  inline void set_allocated_contractdocumentdate(::std::string* contractdocumentdate);

  // required string ContractDocumentNumber = 11;
  inline bool has_contractdocumentnumber() const;
  inline void clear_contractdocumentnumber();
  static const int kContractDocumentNumberFieldNumber = 11;
  inline const ::std::string& contractdocumentnumber() const;
  inline void set_contractdocumentnumber(const ::std::string& value);
  inline void set_contractdocumentnumber(const char* value);
  inline void set_contractdocumentnumber(const char* value, size_t size);
  inline ::std::string* mutable_contractdocumentnumber();
  inline ::std::string* release_contractdocumentnumber();
  inline void set_allocated_contractdocumentnumber(::std::string* contractdocumentnumber);

  // @@protoc_insertion_point(class_scope:PriceListAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_pricelisteffectivedate();
  inline void clear_has_pricelisteffectivedate();
  inline void set_has_contractdocumentdate();
  inline void clear_has_contractdocumentdate();
  inline void set_has_contractdocumentnumber();
  inline void clear_has_contractdocumentnumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > subordinatedocumentids_;
  ::std::string* customdocumentid_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* pricelisteffectivedate_;
  ::std::string* contractdocumentdate_;
  ::std::string* contractdocumentnumber_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static PriceListAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ReconciliationActAttachment : public ::google::protobuf::Message {
 public:
  ReconciliationActAttachment();
  virtual ~ReconciliationActAttachment();

  ReconciliationActAttachment(const ReconciliationActAttachment& from);

  inline ReconciliationActAttachment& operator=(const ReconciliationActAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReconciliationActAttachment& default_instance();

  void Swap(ReconciliationActAttachment* other);

  // implements Message ----------------------------------------------

  ReconciliationActAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReconciliationActAttachment& from);
  void MergeFrom(const ReconciliationActAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::SignedContent& signedcontent() const;
  inline ::SignedContent* mutable_signedcontent();
  inline ::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::DocumentId& initialdocumentids(int index) const;
  inline ::DocumentId* mutable_initialdocumentids(int index);
  inline ::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_initialdocumentids();

  // repeated .DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::DocumentId& subordinatedocumentids(int index) const;
  inline ::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string CustomDocumentId = 6;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 6;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // required string DocumentDate = 7;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 7;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 8;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 8;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // optional bool NeedReceipt = 9 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 9;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:ReconciliationActAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > subordinatedocumentids_;
  ::std::string* customdocumentid_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static ReconciliationActAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ContractAttachment : public ::google::protobuf::Message {
 public:
  ContractAttachment();
  virtual ~ContractAttachment();

  ContractAttachment(const ContractAttachment& from);

  inline ContractAttachment& operator=(const ContractAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContractAttachment& default_instance();

  void Swap(ContractAttachment* other);

  // implements Message ----------------------------------------------

  ContractAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContractAttachment& from);
  void MergeFrom(const ContractAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::SignedContent& signedcontent() const;
  inline ::SignedContent* mutable_signedcontent();
  inline ::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::DocumentId& initialdocumentids(int index) const;
  inline ::DocumentId* mutable_initialdocumentids(int index);
  inline ::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_initialdocumentids();

  // repeated .DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::DocumentId& subordinatedocumentids(int index) const;
  inline ::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string CustomDocumentId = 6;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 6;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // required string DocumentDate = 7;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 7;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 8;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 8;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // optional string ContractPrice = 9;
  inline bool has_contractprice() const;
  inline void clear_contractprice();
  static const int kContractPriceFieldNumber = 9;
  inline const ::std::string& contractprice() const;
  inline void set_contractprice(const ::std::string& value);
  inline void set_contractprice(const char* value);
  inline void set_contractprice(const char* value, size_t size);
  inline ::std::string* mutable_contractprice();
  inline ::std::string* release_contractprice();
  inline void set_allocated_contractprice(::std::string* contractprice);

  // optional string ContractType = 10;
  inline bool has_contracttype() const;
  inline void clear_contracttype();
  static const int kContractTypeFieldNumber = 10;
  inline const ::std::string& contracttype() const;
  inline void set_contracttype(const ::std::string& value);
  inline void set_contracttype(const char* value);
  inline void set_contracttype(const char* value, size_t size);
  inline ::std::string* mutable_contracttype();
  inline ::std::string* release_contracttype();
  inline void set_allocated_contracttype(::std::string* contracttype);

  // optional bool NeedReceipt = 11 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 11;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:ContractAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_contractprice();
  inline void clear_has_contractprice();
  inline void set_has_contracttype();
  inline void clear_has_contracttype();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > subordinatedocumentids_;
  ::std::string* customdocumentid_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* contractprice_;
  ::std::string* contracttype_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static ContractAttachment* default_instance_;
};
// -------------------------------------------------------------------

class Torg13Attachment : public ::google::protobuf::Message {
 public:
  Torg13Attachment();
  virtual ~Torg13Attachment();

  Torg13Attachment(const Torg13Attachment& from);

  inline Torg13Attachment& operator=(const Torg13Attachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Torg13Attachment& default_instance();

  void Swap(Torg13Attachment* other);

  // implements Message ----------------------------------------------

  Torg13Attachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Torg13Attachment& from);
  void MergeFrom(const Torg13Attachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::SignedContent& signedcontent() const;
  inline ::SignedContent* mutable_signedcontent();
  inline ::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::DocumentId& initialdocumentids(int index) const;
  inline ::DocumentId* mutable_initialdocumentids(int index);
  inline ::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_initialdocumentids();

  // repeated .DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::DocumentId& subordinatedocumentids(int index) const;
  inline ::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_subordinatedocumentids();

  // required string DocumentDate = 6;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 6;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // required string DocumentNumber = 7;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 7;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // required string Total = 8;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 8;
  inline const ::std::string& total() const;
  inline void set_total(const ::std::string& value);
  inline void set_total(const char* value);
  inline void set_total(const char* value, size_t size);
  inline ::std::string* mutable_total();
  inline ::std::string* release_total();
  inline void set_allocated_total(::std::string* total);

  // optional string CustomDocumentId = 9;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 9;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional string Grounds = 10;
  inline bool has_grounds() const;
  inline void clear_grounds();
  static const int kGroundsFieldNumber = 10;
  inline const ::std::string& grounds() const;
  inline void set_grounds(const ::std::string& value);
  inline void set_grounds(const char* value);
  inline void set_grounds(const char* value, size_t size);
  inline ::std::string* mutable_grounds();
  inline ::std::string* release_grounds();
  inline void set_allocated_grounds(::std::string* grounds);

  // optional bool NeedReceipt = 11 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 11;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:Torg13Attachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_grounds();
  inline void clear_has_grounds();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > subordinatedocumentids_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  ::std::string* total_;
  ::std::string* customdocumentid_;
  ::std::string* grounds_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static Torg13Attachment* default_instance_;
};
// -------------------------------------------------------------------

class ServiceDetailsAttachment : public ::google::protobuf::Message {
 public:
  ServiceDetailsAttachment();
  virtual ~ServiceDetailsAttachment();

  ServiceDetailsAttachment(const ServiceDetailsAttachment& from);

  inline ServiceDetailsAttachment& operator=(const ServiceDetailsAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceDetailsAttachment& default_instance();

  void Swap(ServiceDetailsAttachment* other);

  // implements Message ----------------------------------------------

  ServiceDetailsAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceDetailsAttachment& from);
  void MergeFrom(const ServiceDetailsAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SignedContent SignedContent = 1;
  inline bool has_signedcontent() const;
  inline void clear_signedcontent();
  static const int kSignedContentFieldNumber = 1;
  inline const ::SignedContent& signedcontent() const;
  inline ::SignedContent* mutable_signedcontent();
  inline ::SignedContent* release_signedcontent();
  inline void set_allocated_signedcontent(::SignedContent* signedcontent);

  // required string FileName = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string Comment = 3;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 3;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // repeated .DocumentId InitialDocumentIds = 4;
  inline int initialdocumentids_size() const;
  inline void clear_initialdocumentids();
  static const int kInitialDocumentIdsFieldNumber = 4;
  inline const ::DocumentId& initialdocumentids(int index) const;
  inline ::DocumentId* mutable_initialdocumentids(int index);
  inline ::DocumentId* add_initialdocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      initialdocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_initialdocumentids();

  // repeated .DocumentId SubordinateDocumentIds = 5;
  inline int subordinatedocumentids_size() const;
  inline void clear_subordinatedocumentids();
  static const int kSubordinateDocumentIdsFieldNumber = 5;
  inline const ::DocumentId& subordinatedocumentids(int index) const;
  inline ::DocumentId* mutable_subordinatedocumentids(int index);
  inline ::DocumentId* add_subordinatedocumentids();
  inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
      subordinatedocumentids() const;
  inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
      mutable_subordinatedocumentids();

  // optional string CustomDocumentId = 6;
  inline bool has_customdocumentid() const;
  inline void clear_customdocumentid();
  static const int kCustomDocumentIdFieldNumber = 6;
  inline const ::std::string& customdocumentid() const;
  inline void set_customdocumentid(const ::std::string& value);
  inline void set_customdocumentid(const char* value);
  inline void set_customdocumentid(const char* value, size_t size);
  inline ::std::string* mutable_customdocumentid();
  inline ::std::string* release_customdocumentid();
  inline void set_allocated_customdocumentid(::std::string* customdocumentid);

  // optional string DocumentDate = 7;
  inline bool has_documentdate() const;
  inline void clear_documentdate();
  static const int kDocumentDateFieldNumber = 7;
  inline const ::std::string& documentdate() const;
  inline void set_documentdate(const ::std::string& value);
  inline void set_documentdate(const char* value);
  inline void set_documentdate(const char* value, size_t size);
  inline ::std::string* mutable_documentdate();
  inline ::std::string* release_documentdate();
  inline void set_allocated_documentdate(::std::string* documentdate);

  // optional string DocumentNumber = 8;
  inline bool has_documentnumber() const;
  inline void clear_documentnumber();
  static const int kDocumentNumberFieldNumber = 8;
  inline const ::std::string& documentnumber() const;
  inline void set_documentnumber(const ::std::string& value);
  inline void set_documentnumber(const char* value);
  inline void set_documentnumber(const char* value, size_t size);
  inline ::std::string* mutable_documentnumber();
  inline ::std::string* release_documentnumber();
  inline void set_allocated_documentnumber(::std::string* documentnumber);

  // optional bool NeedReceipt = 9 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 9;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);

  // @@protoc_insertion_point(class_scope:ServiceDetailsAttachment)
 private:
  inline void set_has_signedcontent();
  inline void clear_has_signedcontent();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_customdocumentid();
  inline void clear_has_customdocumentid();
  inline void set_has_documentdate();
  inline void clear_has_documentdate();
  inline void set_has_documentnumber();
  inline void clear_has_documentnumber();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SignedContent* signedcontent_;
  ::std::string* filename_;
  ::std::string* comment_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > initialdocumentids_;
  ::google::protobuf::RepeatedPtrField< ::DocumentId > subordinatedocumentids_;
  ::std::string* customdocumentid_;
  ::std::string* documentdate_;
  ::std::string* documentnumber_;
  bool needreceipt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static ServiceDetailsAttachment* default_instance_;
};
// -------------------------------------------------------------------

class DocumentId : public ::google::protobuf::Message {
 public:
  DocumentId();
  virtual ~DocumentId();

  DocumentId(const DocumentId& from);

  inline DocumentId& operator=(const DocumentId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentId& default_instance();

  void Swap(DocumentId* other);

  // implements Message ----------------------------------------------

  DocumentId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentId& from);
  void MergeFrom(const DocumentId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string MessageId = 1;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 1;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  inline void set_allocated_messageid(::std::string* messageid);

  // required string EntityId = 2;
  inline bool has_entityid() const;
  inline void clear_entityid();
  static const int kEntityIdFieldNumber = 2;
  inline const ::std::string& entityid() const;
  inline void set_entityid(const ::std::string& value);
  inline void set_entityid(const char* value);
  inline void set_entityid(const char* value, size_t size);
  inline ::std::string* mutable_entityid();
  inline ::std::string* release_entityid();
  inline void set_allocated_entityid(::std::string* entityid);

  // @@protoc_insertion_point(class_scope:DocumentId)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_entityid();
  inline void clear_has_entityid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* messageid_;
  ::std::string* entityid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MessageToPost_2eproto();
  friend void protobuf_AssignDesc_MessageToPost_2eproto();
  friend void protobuf_ShutdownFile_MessageToPost_2eproto();

  void InitAsDefaultInstance();
  static DocumentId* default_instance_;
};
// ===================================================================


// ===================================================================

// MessageToPost

// required string FromBoxId = 1;
inline bool MessageToPost::has_fromboxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageToPost::set_has_fromboxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageToPost::clear_has_fromboxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageToPost::clear_fromboxid() {
  if (fromboxid_ != &::google::protobuf::internal::kEmptyString) {
    fromboxid_->clear();
  }
  clear_has_fromboxid();
}
inline const ::std::string& MessageToPost::fromboxid() const {
  return *fromboxid_;
}
inline void MessageToPost::set_fromboxid(const ::std::string& value) {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  fromboxid_->assign(value);
}
inline void MessageToPost::set_fromboxid(const char* value) {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  fromboxid_->assign(value);
}
inline void MessageToPost::set_fromboxid(const char* value, size_t size) {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  fromboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageToPost::mutable_fromboxid() {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  return fromboxid_;
}
inline ::std::string* MessageToPost::release_fromboxid() {
  clear_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromboxid_;
    fromboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageToPost::set_allocated_fromboxid(::std::string* fromboxid) {
  if (fromboxid_ != &::google::protobuf::internal::kEmptyString) {
    delete fromboxid_;
  }
  if (fromboxid) {
    set_has_fromboxid();
    fromboxid_ = fromboxid;
  } else {
    clear_has_fromboxid();
    fromboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ToBoxId = 2;
inline bool MessageToPost::has_toboxid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageToPost::set_has_toboxid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageToPost::clear_has_toboxid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageToPost::clear_toboxid() {
  if (toboxid_ != &::google::protobuf::internal::kEmptyString) {
    toboxid_->clear();
  }
  clear_has_toboxid();
}
inline const ::std::string& MessageToPost::toboxid() const {
  return *toboxid_;
}
inline void MessageToPost::set_toboxid(const ::std::string& value) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(value);
}
inline void MessageToPost::set_toboxid(const char* value) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(value);
}
inline void MessageToPost::set_toboxid(const char* value, size_t size) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageToPost::mutable_toboxid() {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  return toboxid_;
}
inline ::std::string* MessageToPost::release_toboxid() {
  clear_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toboxid_;
    toboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageToPost::set_allocated_toboxid(::std::string* toboxid) {
  if (toboxid_ != &::google::protobuf::internal::kEmptyString) {
    delete toboxid_;
  }
  if (toboxid) {
    set_has_toboxid();
    toboxid_ = toboxid;
  } else {
    clear_has_toboxid();
    toboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .XmlDocumentAttachment Invoices = 3;
inline int MessageToPost::invoices_size() const {
  return invoices_.size();
}
inline void MessageToPost::clear_invoices() {
  invoices_.Clear();
}
inline const ::XmlDocumentAttachment& MessageToPost::invoices(int index) const {
  return invoices_.Get(index);
}
inline ::XmlDocumentAttachment* MessageToPost::mutable_invoices(int index) {
  return invoices_.Mutable(index);
}
inline ::XmlDocumentAttachment* MessageToPost::add_invoices() {
  return invoices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >&
MessageToPost::invoices() const {
  return invoices_;
}
inline ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >*
MessageToPost::mutable_invoices() {
  return &invoices_;
}

// repeated .NonformalizedAttachment NonformalizedDocuments = 4;
inline int MessageToPost::nonformalizeddocuments_size() const {
  return nonformalizeddocuments_.size();
}
inline void MessageToPost::clear_nonformalizeddocuments() {
  nonformalizeddocuments_.Clear();
}
inline const ::NonformalizedAttachment& MessageToPost::nonformalizeddocuments(int index) const {
  return nonformalizeddocuments_.Get(index);
}
inline ::NonformalizedAttachment* MessageToPost::mutable_nonformalizeddocuments(int index) {
  return nonformalizeddocuments_.Mutable(index);
}
inline ::NonformalizedAttachment* MessageToPost::add_nonformalizeddocuments() {
  return nonformalizeddocuments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >&
MessageToPost::nonformalizeddocuments() const {
  return nonformalizeddocuments_;
}
inline ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >*
MessageToPost::mutable_nonformalizeddocuments() {
  return &nonformalizeddocuments_;
}

// repeated .BasicDocumentAttachment Torg12Documents = 5;
inline int MessageToPost::torg12documents_size() const {
  return torg12documents_.size();
}
inline void MessageToPost::clear_torg12documents() {
  torg12documents_.Clear();
}
inline const ::BasicDocumentAttachment& MessageToPost::torg12documents(int index) const {
  return torg12documents_.Get(index);
}
inline ::BasicDocumentAttachment* MessageToPost::mutable_torg12documents(int index) {
  return torg12documents_.Mutable(index);
}
inline ::BasicDocumentAttachment* MessageToPost::add_torg12documents() {
  return torg12documents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >&
MessageToPost::torg12documents() const {
  return torg12documents_;
}
inline ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >*
MessageToPost::mutable_torg12documents() {
  return &torg12documents_;
}

// optional .TrustConnectionRequestAttachment TrustConnectionRequest = 6;
inline bool MessageToPost::has_trustconnectionrequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageToPost::set_has_trustconnectionrequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageToPost::clear_has_trustconnectionrequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageToPost::clear_trustconnectionrequest() {
  if (trustconnectionrequest_ != NULL) trustconnectionrequest_->::TrustConnectionRequestAttachment::Clear();
  clear_has_trustconnectionrequest();
}
inline const ::TrustConnectionRequestAttachment& MessageToPost::trustconnectionrequest() const {
  return trustconnectionrequest_ != NULL ? *trustconnectionrequest_ : *default_instance_->trustconnectionrequest_;
}
inline ::TrustConnectionRequestAttachment* MessageToPost::mutable_trustconnectionrequest() {
  set_has_trustconnectionrequest();
  if (trustconnectionrequest_ == NULL) trustconnectionrequest_ = new ::TrustConnectionRequestAttachment;
  return trustconnectionrequest_;
}
inline ::TrustConnectionRequestAttachment* MessageToPost::release_trustconnectionrequest() {
  clear_has_trustconnectionrequest();
  ::TrustConnectionRequestAttachment* temp = trustconnectionrequest_;
  trustconnectionrequest_ = NULL;
  return temp;
}
inline void MessageToPost::set_allocated_trustconnectionrequest(::TrustConnectionRequestAttachment* trustconnectionrequest) {
  delete trustconnectionrequest_;
  trustconnectionrequest_ = trustconnectionrequest;
  if (trustconnectionrequest) {
    set_has_trustconnectionrequest();
  } else {
    clear_has_trustconnectionrequest();
  }
}

// repeated .BasicDocumentAttachment AcceptanceCertificates = 7;
inline int MessageToPost::acceptancecertificates_size() const {
  return acceptancecertificates_.size();
}
inline void MessageToPost::clear_acceptancecertificates() {
  acceptancecertificates_.Clear();
}
inline const ::BasicDocumentAttachment& MessageToPost::acceptancecertificates(int index) const {
  return acceptancecertificates_.Get(index);
}
inline ::BasicDocumentAttachment* MessageToPost::mutable_acceptancecertificates(int index) {
  return acceptancecertificates_.Mutable(index);
}
inline ::BasicDocumentAttachment* MessageToPost::add_acceptancecertificates() {
  return acceptancecertificates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >&
MessageToPost::acceptancecertificates() const {
  return acceptancecertificates_;
}
inline ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >*
MessageToPost::mutable_acceptancecertificates() {
  return &acceptancecertificates_;
}

// repeated .StructuredDataAttachment StructuredDataAttachments = 8;
inline int MessageToPost::structureddataattachments_size() const {
  return structureddataattachments_.size();
}
inline void MessageToPost::clear_structureddataattachments() {
  structureddataattachments_.Clear();
}
inline const ::StructuredDataAttachment& MessageToPost::structureddataattachments(int index) const {
  return structureddataattachments_.Get(index);
}
inline ::StructuredDataAttachment* MessageToPost::mutable_structureddataattachments(int index) {
  return structureddataattachments_.Mutable(index);
}
inline ::StructuredDataAttachment* MessageToPost::add_structureddataattachments() {
  return structureddataattachments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StructuredDataAttachment >&
MessageToPost::structureddataattachments() const {
  return structureddataattachments_;
}
inline ::google::protobuf::RepeatedPtrField< ::StructuredDataAttachment >*
MessageToPost::mutable_structureddataattachments() {
  return &structureddataattachments_;
}

// repeated .BasicDocumentAttachment ProformaInvoices = 9;
inline int MessageToPost::proformainvoices_size() const {
  return proformainvoices_.size();
}
inline void MessageToPost::clear_proformainvoices() {
  proformainvoices_.Clear();
}
inline const ::BasicDocumentAttachment& MessageToPost::proformainvoices(int index) const {
  return proformainvoices_.Get(index);
}
inline ::BasicDocumentAttachment* MessageToPost::mutable_proformainvoices(int index) {
  return proformainvoices_.Mutable(index);
}
inline ::BasicDocumentAttachment* MessageToPost::add_proformainvoices() {
  return proformainvoices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >&
MessageToPost::proformainvoices() const {
  return proformainvoices_;
}
inline ::google::protobuf::RepeatedPtrField< ::BasicDocumentAttachment >*
MessageToPost::mutable_proformainvoices() {
  return &proformainvoices_;
}

// repeated .XmlDocumentAttachment XmlTorg12SellerTitles = 10;
inline int MessageToPost::xmltorg12sellertitles_size() const {
  return xmltorg12sellertitles_.size();
}
inline void MessageToPost::clear_xmltorg12sellertitles() {
  xmltorg12sellertitles_.Clear();
}
inline const ::XmlDocumentAttachment& MessageToPost::xmltorg12sellertitles(int index) const {
  return xmltorg12sellertitles_.Get(index);
}
inline ::XmlDocumentAttachment* MessageToPost::mutable_xmltorg12sellertitles(int index) {
  return xmltorg12sellertitles_.Mutable(index);
}
inline ::XmlDocumentAttachment* MessageToPost::add_xmltorg12sellertitles() {
  return xmltorg12sellertitles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >&
MessageToPost::xmltorg12sellertitles() const {
  return xmltorg12sellertitles_;
}
inline ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >*
MessageToPost::mutable_xmltorg12sellertitles() {
  return &xmltorg12sellertitles_;
}

// repeated .XmlDocumentAttachment XmlAcceptanceCertificateSellerTitles = 11;
inline int MessageToPost::xmlacceptancecertificatesellertitles_size() const {
  return xmlacceptancecertificatesellertitles_.size();
}
inline void MessageToPost::clear_xmlacceptancecertificatesellertitles() {
  xmlacceptancecertificatesellertitles_.Clear();
}
inline const ::XmlDocumentAttachment& MessageToPost::xmlacceptancecertificatesellertitles(int index) const {
  return xmlacceptancecertificatesellertitles_.Get(index);
}
inline ::XmlDocumentAttachment* MessageToPost::mutable_xmlacceptancecertificatesellertitles(int index) {
  return xmlacceptancecertificatesellertitles_.Mutable(index);
}
inline ::XmlDocumentAttachment* MessageToPost::add_xmlacceptancecertificatesellertitles() {
  return xmlacceptancecertificatesellertitles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >&
MessageToPost::xmlacceptancecertificatesellertitles() const {
  return xmlacceptancecertificatesellertitles_;
}
inline ::google::protobuf::RepeatedPtrField< ::XmlDocumentAttachment >*
MessageToPost::mutable_xmlacceptancecertificatesellertitles() {
  return &xmlacceptancecertificatesellertitles_;
}

// optional string ToDepartmentId = 12;
inline bool MessageToPost::has_todepartmentid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MessageToPost::set_has_todepartmentid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MessageToPost::clear_has_todepartmentid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MessageToPost::clear_todepartmentid() {
  if (todepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    todepartmentid_->clear();
  }
  clear_has_todepartmentid();
}
inline const ::std::string& MessageToPost::todepartmentid() const {
  return *todepartmentid_;
}
inline void MessageToPost::set_todepartmentid(const ::std::string& value) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(value);
}
inline void MessageToPost::set_todepartmentid(const char* value) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(value);
}
inline void MessageToPost::set_todepartmentid(const char* value, size_t size) {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  todepartmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageToPost::mutable_todepartmentid() {
  set_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    todepartmentid_ = new ::std::string;
  }
  return todepartmentid_;
}
inline ::std::string* MessageToPost::release_todepartmentid() {
  clear_has_todepartmentid();
  if (todepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = todepartmentid_;
    todepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageToPost::set_allocated_todepartmentid(::std::string* todepartmentid) {
  if (todepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete todepartmentid_;
  }
  if (todepartmentid) {
    set_has_todepartmentid();
    todepartmentid_ = todepartmentid;
  } else {
    clear_has_todepartmentid();
    todepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool IsDraft = 13 [default = false];
inline bool MessageToPost::has_isdraft() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MessageToPost::set_has_isdraft() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MessageToPost::clear_has_isdraft() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MessageToPost::clear_isdraft() {
  isdraft_ = false;
  clear_has_isdraft();
}
inline bool MessageToPost::isdraft() const {
  return isdraft_;
}
inline void MessageToPost::set_isdraft(bool value) {
  set_has_isdraft();
  isdraft_ = value;
}

// optional bool LockDraft = 14 [default = false];
inline bool MessageToPost::has_lockdraft() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MessageToPost::set_has_lockdraft() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MessageToPost::clear_has_lockdraft() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MessageToPost::clear_lockdraft() {
  lockdraft_ = false;
  clear_has_lockdraft();
}
inline bool MessageToPost::lockdraft() const {
  return lockdraft_;
}
inline void MessageToPost::set_lockdraft(bool value) {
  set_has_lockdraft();
  lockdraft_ = value;
}

// optional bool StrictDraftValidation = 15 [default = true];
inline bool MessageToPost::has_strictdraftvalidation() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MessageToPost::set_has_strictdraftvalidation() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MessageToPost::clear_has_strictdraftvalidation() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MessageToPost::clear_strictdraftvalidation() {
  strictdraftvalidation_ = true;
  clear_has_strictdraftvalidation();
}
inline bool MessageToPost::strictdraftvalidation() const {
  return strictdraftvalidation_;
}
inline void MessageToPost::set_strictdraftvalidation(bool value) {
  set_has_strictdraftvalidation();
  strictdraftvalidation_ = value;
}

// optional bool IsInternal = 16 [default = false];
inline bool MessageToPost::has_isinternal() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MessageToPost::set_has_isinternal() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MessageToPost::clear_has_isinternal() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MessageToPost::clear_isinternal() {
  isinternal_ = false;
  clear_has_isinternal();
}
inline bool MessageToPost::isinternal() const {
  return isinternal_;
}
inline void MessageToPost::set_isinternal(bool value) {
  set_has_isinternal();
  isinternal_ = value;
}

// optional string FromDepartmentId = 17;
inline bool MessageToPost::has_fromdepartmentid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MessageToPost::set_has_fromdepartmentid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MessageToPost::clear_has_fromdepartmentid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MessageToPost::clear_fromdepartmentid() {
  if (fromdepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_->clear();
  }
  clear_has_fromdepartmentid();
}
inline const ::std::string& MessageToPost::fromdepartmentid() const {
  return *fromdepartmentid_;
}
inline void MessageToPost::set_fromdepartmentid(const ::std::string& value) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(value);
}
inline void MessageToPost::set_fromdepartmentid(const char* value) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(value);
}
inline void MessageToPost::set_fromdepartmentid(const char* value, size_t size) {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  fromdepartmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageToPost::mutable_fromdepartmentid() {
  set_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    fromdepartmentid_ = new ::std::string;
  }
  return fromdepartmentid_;
}
inline ::std::string* MessageToPost::release_fromdepartmentid() {
  clear_has_fromdepartmentid();
  if (fromdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromdepartmentid_;
    fromdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageToPost::set_allocated_fromdepartmentid(::std::string* fromdepartmentid) {
  if (fromdepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    delete fromdepartmentid_;
  }
  if (fromdepartmentid) {
    set_has_fromdepartmentid();
    fromdepartmentid_ = fromdepartmentid;
  } else {
    clear_has_fromdepartmentid();
    fromdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool DelaySend = 18 [default = false];
inline bool MessageToPost::has_delaysend() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MessageToPost::set_has_delaysend() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MessageToPost::clear_has_delaysend() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MessageToPost::clear_delaysend() {
  delaysend_ = false;
  clear_has_delaysend();
}
inline bool MessageToPost::delaysend() const {
  return delaysend_;
}
inline void MessageToPost::set_delaysend(bool value) {
  set_has_delaysend();
  delaysend_ = value;
}

// repeated .PriceListAttachment PriceLists = 19;
inline int MessageToPost::pricelists_size() const {
  return pricelists_.size();
}
inline void MessageToPost::clear_pricelists() {
  pricelists_.Clear();
}
inline const ::PriceListAttachment& MessageToPost::pricelists(int index) const {
  return pricelists_.Get(index);
}
inline ::PriceListAttachment* MessageToPost::mutable_pricelists(int index) {
  return pricelists_.Mutable(index);
}
inline ::PriceListAttachment* MessageToPost::add_pricelists() {
  return pricelists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PriceListAttachment >&
MessageToPost::pricelists() const {
  return pricelists_;
}
inline ::google::protobuf::RepeatedPtrField< ::PriceListAttachment >*
MessageToPost::mutable_pricelists() {
  return &pricelists_;
}

// repeated .NonformalizedAttachment PriceListAgreements = 20;
inline int MessageToPost::pricelistagreements_size() const {
  return pricelistagreements_.size();
}
inline void MessageToPost::clear_pricelistagreements() {
  pricelistagreements_.Clear();
}
inline const ::NonformalizedAttachment& MessageToPost::pricelistagreements(int index) const {
  return pricelistagreements_.Get(index);
}
inline ::NonformalizedAttachment* MessageToPost::mutable_pricelistagreements(int index) {
  return pricelistagreements_.Mutable(index);
}
inline ::NonformalizedAttachment* MessageToPost::add_pricelistagreements() {
  return pricelistagreements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >&
MessageToPost::pricelistagreements() const {
  return pricelistagreements_;
}
inline ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >*
MessageToPost::mutable_pricelistagreements() {
  return &pricelistagreements_;
}

// repeated .NonformalizedAttachment CertificateRegistries = 21;
inline int MessageToPost::certificateregistries_size() const {
  return certificateregistries_.size();
}
inline void MessageToPost::clear_certificateregistries() {
  certificateregistries_.Clear();
}
inline const ::NonformalizedAttachment& MessageToPost::certificateregistries(int index) const {
  return certificateregistries_.Get(index);
}
inline ::NonformalizedAttachment* MessageToPost::mutable_certificateregistries(int index) {
  return certificateregistries_.Mutable(index);
}
inline ::NonformalizedAttachment* MessageToPost::add_certificateregistries() {
  return certificateregistries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >&
MessageToPost::certificateregistries() const {
  return certificateregistries_;
}
inline ::google::protobuf::RepeatedPtrField< ::NonformalizedAttachment >*
MessageToPost::mutable_certificateregistries() {
  return &certificateregistries_;
}

// repeated .ReconciliationActAttachment ReconciliationActs = 22;
inline int MessageToPost::reconciliationacts_size() const {
  return reconciliationacts_.size();
}
inline void MessageToPost::clear_reconciliationacts() {
  reconciliationacts_.Clear();
}
inline const ::ReconciliationActAttachment& MessageToPost::reconciliationacts(int index) const {
  return reconciliationacts_.Get(index);
}
inline ::ReconciliationActAttachment* MessageToPost::mutable_reconciliationacts(int index) {
  return reconciliationacts_.Mutable(index);
}
inline ::ReconciliationActAttachment* MessageToPost::add_reconciliationacts() {
  return reconciliationacts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ReconciliationActAttachment >&
MessageToPost::reconciliationacts() const {
  return reconciliationacts_;
}
inline ::google::protobuf::RepeatedPtrField< ::ReconciliationActAttachment >*
MessageToPost::mutable_reconciliationacts() {
  return &reconciliationacts_;
}

// repeated .ContractAttachment Contracts = 23;
inline int MessageToPost::contracts_size() const {
  return contracts_.size();
}
inline void MessageToPost::clear_contracts() {
  contracts_.Clear();
}
inline const ::ContractAttachment& MessageToPost::contracts(int index) const {
  return contracts_.Get(index);
}
inline ::ContractAttachment* MessageToPost::mutable_contracts(int index) {
  return contracts_.Mutable(index);
}
inline ::ContractAttachment* MessageToPost::add_contracts() {
  return contracts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ContractAttachment >&
MessageToPost::contracts() const {
  return contracts_;
}
inline ::google::protobuf::RepeatedPtrField< ::ContractAttachment >*
MessageToPost::mutable_contracts() {
  return &contracts_;
}

// repeated .Torg13Attachment Torg13Documents = 24;
inline int MessageToPost::torg13documents_size() const {
  return torg13documents_.size();
}
inline void MessageToPost::clear_torg13documents() {
  torg13documents_.Clear();
}
inline const ::Torg13Attachment& MessageToPost::torg13documents(int index) const {
  return torg13documents_.Get(index);
}
inline ::Torg13Attachment* MessageToPost::mutable_torg13documents(int index) {
  return torg13documents_.Mutable(index);
}
inline ::Torg13Attachment* MessageToPost::add_torg13documents() {
  return torg13documents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Torg13Attachment >&
MessageToPost::torg13documents() const {
  return torg13documents_;
}
inline ::google::protobuf::RepeatedPtrField< ::Torg13Attachment >*
MessageToPost::mutable_torg13documents() {
  return &torg13documents_;
}

// repeated .ServiceDetailsAttachment ServiceDetailsDocuments = 25;
inline int MessageToPost::servicedetailsdocuments_size() const {
  return servicedetailsdocuments_.size();
}
inline void MessageToPost::clear_servicedetailsdocuments() {
  servicedetailsdocuments_.Clear();
}
inline const ::ServiceDetailsAttachment& MessageToPost::servicedetailsdocuments(int index) const {
  return servicedetailsdocuments_.Get(index);
}
inline ::ServiceDetailsAttachment* MessageToPost::mutable_servicedetailsdocuments(int index) {
  return servicedetailsdocuments_.Mutable(index);
}
inline ::ServiceDetailsAttachment* MessageToPost::add_servicedetailsdocuments() {
  return servicedetailsdocuments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ServiceDetailsAttachment >&
MessageToPost::servicedetailsdocuments() const {
  return servicedetailsdocuments_;
}
inline ::google::protobuf::RepeatedPtrField< ::ServiceDetailsAttachment >*
MessageToPost::mutable_servicedetailsdocuments() {
  return &servicedetailsdocuments_;
}

// -------------------------------------------------------------------

// XmlDocumentAttachment

// required .SignedContent SignedContent = 1;
inline bool XmlDocumentAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XmlDocumentAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XmlDocumentAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XmlDocumentAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::SignedContent& XmlDocumentAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::SignedContent* XmlDocumentAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::SignedContent;
  return signedcontent_;
}
inline ::SignedContent* XmlDocumentAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void XmlDocumentAttachment::set_allocated_signedcontent(::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// optional string Comment = 3;
inline bool XmlDocumentAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XmlDocumentAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XmlDocumentAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XmlDocumentAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& XmlDocumentAttachment::comment() const {
  return *comment_;
}
inline void XmlDocumentAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void XmlDocumentAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void XmlDocumentAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XmlDocumentAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* XmlDocumentAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XmlDocumentAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DocumentId InitialDocumentIds = 4;
inline int XmlDocumentAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void XmlDocumentAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::DocumentId& XmlDocumentAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::DocumentId* XmlDocumentAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::DocumentId* XmlDocumentAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
XmlDocumentAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
XmlDocumentAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .DocumentId SubordinateDocumentIds = 5;
inline int XmlDocumentAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void XmlDocumentAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::DocumentId& XmlDocumentAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::DocumentId* XmlDocumentAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::DocumentId* XmlDocumentAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
XmlDocumentAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
XmlDocumentAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string CustomDocumentId = 6;
inline bool XmlDocumentAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XmlDocumentAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XmlDocumentAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XmlDocumentAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& XmlDocumentAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void XmlDocumentAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void XmlDocumentAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void XmlDocumentAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XmlDocumentAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* XmlDocumentAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XmlDocumentAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignedContent

// optional bytes Content = 1;
inline bool SignedContent::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedContent::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedContent::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedContent::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& SignedContent::content() const {
  return *content_;
}
inline void SignedContent::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SignedContent::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SignedContent::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedContent::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* SignedContent::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedContent::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes Signature = 2;
inline bool SignedContent::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedContent::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedContent::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedContent::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SignedContent::signature() const {
  return *signature_;
}
inline void SignedContent::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedContent::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedContent::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedContent::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SignedContent::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedContent::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool SignByAttorney = 3 [default = false];
inline bool SignedContent::has_signbyattorney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedContent::set_has_signbyattorney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedContent::clear_has_signbyattorney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedContent::clear_signbyattorney() {
  signbyattorney_ = false;
  clear_has_signbyattorney();
}
inline bool SignedContent::signbyattorney() const {
  return signbyattorney_;
}
inline void SignedContent::set_signbyattorney(bool value) {
  set_has_signbyattorney();
  signbyattorney_ = value;
}

// optional string NameOnShelf = 4;
inline bool SignedContent::has_nameonshelf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedContent::set_has_nameonshelf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedContent::clear_has_nameonshelf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedContent::clear_nameonshelf() {
  if (nameonshelf_ != &::google::protobuf::internal::kEmptyString) {
    nameonshelf_->clear();
  }
  clear_has_nameonshelf();
}
inline const ::std::string& SignedContent::nameonshelf() const {
  return *nameonshelf_;
}
inline void SignedContent::set_nameonshelf(const ::std::string& value) {
  set_has_nameonshelf();
  if (nameonshelf_ == &::google::protobuf::internal::kEmptyString) {
    nameonshelf_ = new ::std::string;
  }
  nameonshelf_->assign(value);
}
inline void SignedContent::set_nameonshelf(const char* value) {
  set_has_nameonshelf();
  if (nameonshelf_ == &::google::protobuf::internal::kEmptyString) {
    nameonshelf_ = new ::std::string;
  }
  nameonshelf_->assign(value);
}
inline void SignedContent::set_nameonshelf(const char* value, size_t size) {
  set_has_nameonshelf();
  if (nameonshelf_ == &::google::protobuf::internal::kEmptyString) {
    nameonshelf_ = new ::std::string;
  }
  nameonshelf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedContent::mutable_nameonshelf() {
  set_has_nameonshelf();
  if (nameonshelf_ == &::google::protobuf::internal::kEmptyString) {
    nameonshelf_ = new ::std::string;
  }
  return nameonshelf_;
}
inline ::std::string* SignedContent::release_nameonshelf() {
  clear_has_nameonshelf();
  if (nameonshelf_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nameonshelf_;
    nameonshelf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedContent::set_allocated_nameonshelf(::std::string* nameonshelf) {
  if (nameonshelf_ != &::google::protobuf::internal::kEmptyString) {
    delete nameonshelf_;
  }
  if (nameonshelf) {
    set_has_nameonshelf();
    nameonshelf_ = nameonshelf;
  } else {
    clear_has_nameonshelf();
    nameonshelf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool SignWithTestSignature = 5 [default = false];
inline bool SignedContent::has_signwithtestsignature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignedContent::set_has_signwithtestsignature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignedContent::clear_has_signwithtestsignature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignedContent::clear_signwithtestsignature() {
  signwithtestsignature_ = false;
  clear_has_signwithtestsignature();
}
inline bool SignedContent::signwithtestsignature() const {
  return signwithtestsignature_;
}
inline void SignedContent::set_signwithtestsignature(bool value) {
  set_has_signwithtestsignature();
  signwithtestsignature_ = value;
}

// -------------------------------------------------------------------

// NonformalizedAttachment

// required .SignedContent SignedContent = 1;
inline bool NonformalizedAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NonformalizedAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NonformalizedAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NonformalizedAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::SignedContent& NonformalizedAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::SignedContent* NonformalizedAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::SignedContent;
  return signedcontent_;
}
inline ::SignedContent* NonformalizedAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void NonformalizedAttachment::set_allocated_signedcontent(::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool NonformalizedAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NonformalizedAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NonformalizedAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NonformalizedAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& NonformalizedAttachment::filename() const {
  return *filename_;
}
inline void NonformalizedAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void NonformalizedAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void NonformalizedAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NonformalizedAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* NonformalizedAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NonformalizedAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool NonformalizedAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NonformalizedAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NonformalizedAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NonformalizedAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& NonformalizedAttachment::comment() const {
  return *comment_;
}
inline void NonformalizedAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void NonformalizedAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void NonformalizedAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NonformalizedAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* NonformalizedAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NonformalizedAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedRecipientSignature = 4 [default = false];
inline bool NonformalizedAttachment::has_needrecipientsignature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NonformalizedAttachment::set_has_needrecipientsignature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NonformalizedAttachment::clear_has_needrecipientsignature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NonformalizedAttachment::clear_needrecipientsignature() {
  needrecipientsignature_ = false;
  clear_has_needrecipientsignature();
}
inline bool NonformalizedAttachment::needrecipientsignature() const {
  return needrecipientsignature_;
}
inline void NonformalizedAttachment::set_needrecipientsignature(bool value) {
  set_has_needrecipientsignature();
  needrecipientsignature_ = value;
}

// repeated .DocumentId InitialDocumentIds = 5;
inline int NonformalizedAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void NonformalizedAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::DocumentId& NonformalizedAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::DocumentId* NonformalizedAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::DocumentId* NonformalizedAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
NonformalizedAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
NonformalizedAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .DocumentId SubordinateDocumentIds = 6;
inline int NonformalizedAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void NonformalizedAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::DocumentId& NonformalizedAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::DocumentId* NonformalizedAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::DocumentId* NonformalizedAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
NonformalizedAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
NonformalizedAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string DocumentDate = 7;
inline bool NonformalizedAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NonformalizedAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NonformalizedAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NonformalizedAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& NonformalizedAttachment::documentdate() const {
  return *documentdate_;
}
inline void NonformalizedAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void NonformalizedAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void NonformalizedAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NonformalizedAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* NonformalizedAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NonformalizedAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DocumentNumber = 8;
inline bool NonformalizedAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NonformalizedAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NonformalizedAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NonformalizedAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& NonformalizedAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void NonformalizedAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void NonformalizedAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void NonformalizedAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NonformalizedAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* NonformalizedAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NonformalizedAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 9;
inline bool NonformalizedAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NonformalizedAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NonformalizedAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NonformalizedAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& NonformalizedAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void NonformalizedAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void NonformalizedAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void NonformalizedAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NonformalizedAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* NonformalizedAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NonformalizedAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BasicDocumentAttachment

// required .SignedContent SignedContent = 1;
inline bool BasicDocumentAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicDocumentAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicDocumentAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicDocumentAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::SignedContent& BasicDocumentAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::SignedContent* BasicDocumentAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::SignedContent;
  return signedcontent_;
}
inline ::SignedContent* BasicDocumentAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void BasicDocumentAttachment::set_allocated_signedcontent(::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool BasicDocumentAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicDocumentAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicDocumentAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicDocumentAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& BasicDocumentAttachment::filename() const {
  return *filename_;
}
inline void BasicDocumentAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void BasicDocumentAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void BasicDocumentAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* BasicDocumentAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool BasicDocumentAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasicDocumentAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasicDocumentAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasicDocumentAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& BasicDocumentAttachment::comment() const {
  return *comment_;
}
inline void BasicDocumentAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void BasicDocumentAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void BasicDocumentAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* BasicDocumentAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DocumentId InitialDocumentIds = 4;
inline int BasicDocumentAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void BasicDocumentAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::DocumentId& BasicDocumentAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::DocumentId* BasicDocumentAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::DocumentId* BasicDocumentAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
BasicDocumentAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
BasicDocumentAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .DocumentId SubordinateDocumentIds = 5;
inline int BasicDocumentAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void BasicDocumentAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::DocumentId& BasicDocumentAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::DocumentId* BasicDocumentAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::DocumentId* BasicDocumentAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
BasicDocumentAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
BasicDocumentAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// required string DocumentDate = 6;
inline bool BasicDocumentAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BasicDocumentAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BasicDocumentAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BasicDocumentAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& BasicDocumentAttachment::documentdate() const {
  return *documentdate_;
}
inline void BasicDocumentAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void BasicDocumentAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void BasicDocumentAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* BasicDocumentAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 7;
inline bool BasicDocumentAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BasicDocumentAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BasicDocumentAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BasicDocumentAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& BasicDocumentAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void BasicDocumentAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void BasicDocumentAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void BasicDocumentAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* BasicDocumentAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Total = 8;
inline bool BasicDocumentAttachment::has_total() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BasicDocumentAttachment::set_has_total() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BasicDocumentAttachment::clear_has_total() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BasicDocumentAttachment::clear_total() {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& BasicDocumentAttachment::total() const {
  return *total_;
}
inline void BasicDocumentAttachment::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void BasicDocumentAttachment::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void BasicDocumentAttachment::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  return total_;
}
inline ::std::string* BasicDocumentAttachment::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 9;
inline bool BasicDocumentAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BasicDocumentAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BasicDocumentAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BasicDocumentAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& BasicDocumentAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void BasicDocumentAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void BasicDocumentAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void BasicDocumentAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* BasicDocumentAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Vat = 10;
inline bool BasicDocumentAttachment::has_vat() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BasicDocumentAttachment::set_has_vat() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BasicDocumentAttachment::clear_has_vat() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BasicDocumentAttachment::clear_vat() {
  if (vat_ != &::google::protobuf::internal::kEmptyString) {
    vat_->clear();
  }
  clear_has_vat();
}
inline const ::std::string& BasicDocumentAttachment::vat() const {
  return *vat_;
}
inline void BasicDocumentAttachment::set_vat(const ::std::string& value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void BasicDocumentAttachment::set_vat(const char* value) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(value);
}
inline void BasicDocumentAttachment::set_vat(const char* value, size_t size) {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  vat_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_vat() {
  set_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    vat_ = new ::std::string;
  }
  return vat_;
}
inline ::std::string* BasicDocumentAttachment::release_vat() {
  clear_has_vat();
  if (vat_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vat_;
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_vat(::std::string* vat) {
  if (vat_ != &::google::protobuf::internal::kEmptyString) {
    delete vat_;
  }
  if (vat) {
    set_has_vat();
    vat_ = vat;
  } else {
    clear_has_vat();
    vat_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Grounds = 11;
inline bool BasicDocumentAttachment::has_grounds() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BasicDocumentAttachment::set_has_grounds() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BasicDocumentAttachment::clear_has_grounds() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BasicDocumentAttachment::clear_grounds() {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    grounds_->clear();
  }
  clear_has_grounds();
}
inline const ::std::string& BasicDocumentAttachment::grounds() const {
  return *grounds_;
}
inline void BasicDocumentAttachment::set_grounds(const ::std::string& value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void BasicDocumentAttachment::set_grounds(const char* value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void BasicDocumentAttachment::set_grounds(const char* value, size_t size) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicDocumentAttachment::mutable_grounds() {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  return grounds_;
}
inline ::std::string* BasicDocumentAttachment::release_grounds() {
  clear_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grounds_;
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasicDocumentAttachment::set_allocated_grounds(::std::string* grounds) {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    delete grounds_;
  }
  if (grounds) {
    set_has_grounds();
    grounds_ = grounds;
  } else {
    clear_has_grounds();
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TrustConnectionRequestAttachment

// required .SignedContent SignedContent = 1;
inline bool TrustConnectionRequestAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrustConnectionRequestAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrustConnectionRequestAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrustConnectionRequestAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::SignedContent& TrustConnectionRequestAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::SignedContent* TrustConnectionRequestAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::SignedContent;
  return signedcontent_;
}
inline ::SignedContent* TrustConnectionRequestAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void TrustConnectionRequestAttachment::set_allocated_signedcontent(::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool TrustConnectionRequestAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrustConnectionRequestAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrustConnectionRequestAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrustConnectionRequestAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& TrustConnectionRequestAttachment::filename() const {
  return *filename_;
}
inline void TrustConnectionRequestAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrustConnectionRequestAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* TrustConnectionRequestAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrustConnectionRequestAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool TrustConnectionRequestAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrustConnectionRequestAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrustConnectionRequestAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrustConnectionRequestAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& TrustConnectionRequestAttachment::comment() const {
  return *comment_;
}
inline void TrustConnectionRequestAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrustConnectionRequestAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* TrustConnectionRequestAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrustConnectionRequestAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 4;
inline bool TrustConnectionRequestAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrustConnectionRequestAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrustConnectionRequestAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrustConnectionRequestAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& TrustConnectionRequestAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void TrustConnectionRequestAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void TrustConnectionRequestAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrustConnectionRequestAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* TrustConnectionRequestAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrustConnectionRequestAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StructuredDataAttachment

// required bytes Content = 1;
inline bool StructuredDataAttachment::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StructuredDataAttachment::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StructuredDataAttachment::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StructuredDataAttachment::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& StructuredDataAttachment::content() const {
  return *content_;
}
inline void StructuredDataAttachment::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void StructuredDataAttachment::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void StructuredDataAttachment::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StructuredDataAttachment::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* StructuredDataAttachment::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StructuredDataAttachment::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FileName = 2;
inline bool StructuredDataAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StructuredDataAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StructuredDataAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StructuredDataAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& StructuredDataAttachment::filename() const {
  return *filename_;
}
inline void StructuredDataAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void StructuredDataAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void StructuredDataAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StructuredDataAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* StructuredDataAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StructuredDataAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentId = 3;
inline bool StructuredDataAttachment::has_documentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StructuredDataAttachment::set_has_documentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StructuredDataAttachment::clear_has_documentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StructuredDataAttachment::clear_documentid() {
  if (documentid_ != &::google::protobuf::internal::kEmptyString) {
    documentid_->clear();
  }
  clear_has_documentid();
}
inline const ::std::string& StructuredDataAttachment::documentid() const {
  return *documentid_;
}
inline void StructuredDataAttachment::set_documentid(const ::std::string& value) {
  set_has_documentid();
  if (documentid_ == &::google::protobuf::internal::kEmptyString) {
    documentid_ = new ::std::string;
  }
  documentid_->assign(value);
}
inline void StructuredDataAttachment::set_documentid(const char* value) {
  set_has_documentid();
  if (documentid_ == &::google::protobuf::internal::kEmptyString) {
    documentid_ = new ::std::string;
  }
  documentid_->assign(value);
}
inline void StructuredDataAttachment::set_documentid(const char* value, size_t size) {
  set_has_documentid();
  if (documentid_ == &::google::protobuf::internal::kEmptyString) {
    documentid_ = new ::std::string;
  }
  documentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StructuredDataAttachment::mutable_documentid() {
  set_has_documentid();
  if (documentid_ == &::google::protobuf::internal::kEmptyString) {
    documentid_ = new ::std::string;
  }
  return documentid_;
}
inline ::std::string* StructuredDataAttachment::release_documentid() {
  clear_has_documentid();
  if (documentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentid_;
    documentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StructuredDataAttachment::set_allocated_documentid(::std::string* documentid) {
  if (documentid_ != &::google::protobuf::internal::kEmptyString) {
    delete documentid_;
  }
  if (documentid) {
    set_has_documentid();
    documentid_ = documentid;
  } else {
    clear_has_documentid();
    documentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PriceListAttachment

// required .SignedContent SignedContent = 1;
inline bool PriceListAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PriceListAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PriceListAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PriceListAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::SignedContent& PriceListAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::SignedContent* PriceListAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::SignedContent;
  return signedcontent_;
}
inline ::SignedContent* PriceListAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void PriceListAttachment::set_allocated_signedcontent(::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool PriceListAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PriceListAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PriceListAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PriceListAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& PriceListAttachment::filename() const {
  return *filename_;
}
inline void PriceListAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void PriceListAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void PriceListAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* PriceListAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool PriceListAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PriceListAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PriceListAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PriceListAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& PriceListAttachment::comment() const {
  return *comment_;
}
inline void PriceListAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void PriceListAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void PriceListAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* PriceListAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DocumentId InitialDocumentIds = 4;
inline int PriceListAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void PriceListAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::DocumentId& PriceListAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::DocumentId* PriceListAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::DocumentId* PriceListAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
PriceListAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
PriceListAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .DocumentId SubordinateDocumentIds = 5;
inline int PriceListAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void PriceListAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::DocumentId& PriceListAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::DocumentId* PriceListAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::DocumentId* PriceListAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
PriceListAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
PriceListAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string CustomDocumentId = 6;
inline bool PriceListAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PriceListAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PriceListAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PriceListAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& PriceListAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void PriceListAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void PriceListAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void PriceListAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* PriceListAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentDate = 7;
inline bool PriceListAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PriceListAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PriceListAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PriceListAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& PriceListAttachment::documentdate() const {
  return *documentdate_;
}
inline void PriceListAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void PriceListAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void PriceListAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* PriceListAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 8;
inline bool PriceListAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PriceListAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PriceListAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PriceListAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& PriceListAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void PriceListAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void PriceListAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void PriceListAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* PriceListAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string PriceListEffectiveDate = 9;
inline bool PriceListAttachment::has_pricelisteffectivedate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PriceListAttachment::set_has_pricelisteffectivedate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PriceListAttachment::clear_has_pricelisteffectivedate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PriceListAttachment::clear_pricelisteffectivedate() {
  if (pricelisteffectivedate_ != &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_->clear();
  }
  clear_has_pricelisteffectivedate();
}
inline const ::std::string& PriceListAttachment::pricelisteffectivedate() const {
  return *pricelisteffectivedate_;
}
inline void PriceListAttachment::set_pricelisteffectivedate(const ::std::string& value) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(value);
}
inline void PriceListAttachment::set_pricelisteffectivedate(const char* value) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(value);
}
inline void PriceListAttachment::set_pricelisteffectivedate(const char* value, size_t size) {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  pricelisteffectivedate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_pricelisteffectivedate() {
  set_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    pricelisteffectivedate_ = new ::std::string;
  }
  return pricelisteffectivedate_;
}
inline ::std::string* PriceListAttachment::release_pricelisteffectivedate() {
  clear_has_pricelisteffectivedate();
  if (pricelisteffectivedate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pricelisteffectivedate_;
    pricelisteffectivedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_pricelisteffectivedate(::std::string* pricelisteffectivedate) {
  if (pricelisteffectivedate_ != &::google::protobuf::internal::kEmptyString) {
    delete pricelisteffectivedate_;
  }
  if (pricelisteffectivedate) {
    set_has_pricelisteffectivedate();
    pricelisteffectivedate_ = pricelisteffectivedate;
  } else {
    clear_has_pricelisteffectivedate();
    pricelisteffectivedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ContractDocumentDate = 10;
inline bool PriceListAttachment::has_contractdocumentdate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PriceListAttachment::set_has_contractdocumentdate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PriceListAttachment::clear_has_contractdocumentdate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PriceListAttachment::clear_contractdocumentdate() {
  if (contractdocumentdate_ != &::google::protobuf::internal::kEmptyString) {
    contractdocumentdate_->clear();
  }
  clear_has_contractdocumentdate();
}
inline const ::std::string& PriceListAttachment::contractdocumentdate() const {
  return *contractdocumentdate_;
}
inline void PriceListAttachment::set_contractdocumentdate(const ::std::string& value) {
  set_has_contractdocumentdate();
  if (contractdocumentdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentdate_ = new ::std::string;
  }
  contractdocumentdate_->assign(value);
}
inline void PriceListAttachment::set_contractdocumentdate(const char* value) {
  set_has_contractdocumentdate();
  if (contractdocumentdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentdate_ = new ::std::string;
  }
  contractdocumentdate_->assign(value);
}
inline void PriceListAttachment::set_contractdocumentdate(const char* value, size_t size) {
  set_has_contractdocumentdate();
  if (contractdocumentdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentdate_ = new ::std::string;
  }
  contractdocumentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_contractdocumentdate() {
  set_has_contractdocumentdate();
  if (contractdocumentdate_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentdate_ = new ::std::string;
  }
  return contractdocumentdate_;
}
inline ::std::string* PriceListAttachment::release_contractdocumentdate() {
  clear_has_contractdocumentdate();
  if (contractdocumentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractdocumentdate_;
    contractdocumentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_contractdocumentdate(::std::string* contractdocumentdate) {
  if (contractdocumentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete contractdocumentdate_;
  }
  if (contractdocumentdate) {
    set_has_contractdocumentdate();
    contractdocumentdate_ = contractdocumentdate;
  } else {
    clear_has_contractdocumentdate();
    contractdocumentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ContractDocumentNumber = 11;
inline bool PriceListAttachment::has_contractdocumentnumber() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PriceListAttachment::set_has_contractdocumentnumber() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PriceListAttachment::clear_has_contractdocumentnumber() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PriceListAttachment::clear_contractdocumentnumber() {
  if (contractdocumentnumber_ != &::google::protobuf::internal::kEmptyString) {
    contractdocumentnumber_->clear();
  }
  clear_has_contractdocumentnumber();
}
inline const ::std::string& PriceListAttachment::contractdocumentnumber() const {
  return *contractdocumentnumber_;
}
inline void PriceListAttachment::set_contractdocumentnumber(const ::std::string& value) {
  set_has_contractdocumentnumber();
  if (contractdocumentnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentnumber_ = new ::std::string;
  }
  contractdocumentnumber_->assign(value);
}
inline void PriceListAttachment::set_contractdocumentnumber(const char* value) {
  set_has_contractdocumentnumber();
  if (contractdocumentnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentnumber_ = new ::std::string;
  }
  contractdocumentnumber_->assign(value);
}
inline void PriceListAttachment::set_contractdocumentnumber(const char* value, size_t size) {
  set_has_contractdocumentnumber();
  if (contractdocumentnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentnumber_ = new ::std::string;
  }
  contractdocumentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceListAttachment::mutable_contractdocumentnumber() {
  set_has_contractdocumentnumber();
  if (contractdocumentnumber_ == &::google::protobuf::internal::kEmptyString) {
    contractdocumentnumber_ = new ::std::string;
  }
  return contractdocumentnumber_;
}
inline ::std::string* PriceListAttachment::release_contractdocumentnumber() {
  clear_has_contractdocumentnumber();
  if (contractdocumentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractdocumentnumber_;
    contractdocumentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceListAttachment::set_allocated_contractdocumentnumber(::std::string* contractdocumentnumber) {
  if (contractdocumentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete contractdocumentnumber_;
  }
  if (contractdocumentnumber) {
    set_has_contractdocumentnumber();
    contractdocumentnumber_ = contractdocumentnumber;
  } else {
    clear_has_contractdocumentnumber();
    contractdocumentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReconciliationActAttachment

// required .SignedContent SignedContent = 1;
inline bool ReconciliationActAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReconciliationActAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReconciliationActAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReconciliationActAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::SignedContent& ReconciliationActAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::SignedContent* ReconciliationActAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::SignedContent;
  return signedcontent_;
}
inline ::SignedContent* ReconciliationActAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void ReconciliationActAttachment::set_allocated_signedcontent(::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool ReconciliationActAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReconciliationActAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReconciliationActAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReconciliationActAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ReconciliationActAttachment::filename() const {
  return *filename_;
}
inline void ReconciliationActAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ReconciliationActAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ReconciliationActAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconciliationActAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ReconciliationActAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconciliationActAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool ReconciliationActAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReconciliationActAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReconciliationActAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReconciliationActAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ReconciliationActAttachment::comment() const {
  return *comment_;
}
inline void ReconciliationActAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ReconciliationActAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ReconciliationActAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconciliationActAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ReconciliationActAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconciliationActAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DocumentId InitialDocumentIds = 4;
inline int ReconciliationActAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void ReconciliationActAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::DocumentId& ReconciliationActAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::DocumentId* ReconciliationActAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::DocumentId* ReconciliationActAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
ReconciliationActAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
ReconciliationActAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .DocumentId SubordinateDocumentIds = 5;
inline int ReconciliationActAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void ReconciliationActAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::DocumentId& ReconciliationActAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::DocumentId* ReconciliationActAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::DocumentId* ReconciliationActAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
ReconciliationActAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
ReconciliationActAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string CustomDocumentId = 6;
inline bool ReconciliationActAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReconciliationActAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReconciliationActAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReconciliationActAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& ReconciliationActAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void ReconciliationActAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ReconciliationActAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ReconciliationActAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconciliationActAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* ReconciliationActAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconciliationActAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentDate = 7;
inline bool ReconciliationActAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReconciliationActAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReconciliationActAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReconciliationActAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& ReconciliationActAttachment::documentdate() const {
  return *documentdate_;
}
inline void ReconciliationActAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ReconciliationActAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ReconciliationActAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconciliationActAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* ReconciliationActAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconciliationActAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 8;
inline bool ReconciliationActAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReconciliationActAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReconciliationActAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReconciliationActAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& ReconciliationActAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void ReconciliationActAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ReconciliationActAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ReconciliationActAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReconciliationActAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* ReconciliationActAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReconciliationActAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 9 [default = false];
inline bool ReconciliationActAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReconciliationActAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReconciliationActAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReconciliationActAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool ReconciliationActAttachment::needreceipt() const {
  return needreceipt_;
}
inline void ReconciliationActAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// ContractAttachment

// required .SignedContent SignedContent = 1;
inline bool ContractAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContractAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContractAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContractAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::SignedContent& ContractAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::SignedContent* ContractAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::SignedContent;
  return signedcontent_;
}
inline ::SignedContent* ContractAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void ContractAttachment::set_allocated_signedcontent(::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool ContractAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContractAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContractAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContractAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ContractAttachment::filename() const {
  return *filename_;
}
inline void ContractAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ContractAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ContractAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ContractAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool ContractAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContractAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContractAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContractAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ContractAttachment::comment() const {
  return *comment_;
}
inline void ContractAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ContractAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ContractAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ContractAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DocumentId InitialDocumentIds = 4;
inline int ContractAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void ContractAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::DocumentId& ContractAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::DocumentId* ContractAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::DocumentId* ContractAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
ContractAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
ContractAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .DocumentId SubordinateDocumentIds = 5;
inline int ContractAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void ContractAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::DocumentId& ContractAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::DocumentId* ContractAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::DocumentId* ContractAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
ContractAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
ContractAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string CustomDocumentId = 6;
inline bool ContractAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContractAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContractAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContractAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& ContractAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void ContractAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ContractAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ContractAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* ContractAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentDate = 7;
inline bool ContractAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContractAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContractAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContractAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& ContractAttachment::documentdate() const {
  return *documentdate_;
}
inline void ContractAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ContractAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ContractAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* ContractAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 8;
inline bool ContractAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContractAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContractAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContractAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& ContractAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void ContractAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ContractAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ContractAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* ContractAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ContractPrice = 9;
inline bool ContractAttachment::has_contractprice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ContractAttachment::set_has_contractprice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ContractAttachment::clear_has_contractprice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ContractAttachment::clear_contractprice() {
  if (contractprice_ != &::google::protobuf::internal::kEmptyString) {
    contractprice_->clear();
  }
  clear_has_contractprice();
}
inline const ::std::string& ContractAttachment::contractprice() const {
  return *contractprice_;
}
inline void ContractAttachment::set_contractprice(const ::std::string& value) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(value);
}
inline void ContractAttachment::set_contractprice(const char* value) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(value);
}
inline void ContractAttachment::set_contractprice(const char* value, size_t size) {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  contractprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_contractprice() {
  set_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    contractprice_ = new ::std::string;
  }
  return contractprice_;
}
inline ::std::string* ContractAttachment::release_contractprice() {
  clear_has_contractprice();
  if (contractprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractprice_;
    contractprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_contractprice(::std::string* contractprice) {
  if (contractprice_ != &::google::protobuf::internal::kEmptyString) {
    delete contractprice_;
  }
  if (contractprice) {
    set_has_contractprice();
    contractprice_ = contractprice;
  } else {
    clear_has_contractprice();
    contractprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ContractType = 10;
inline bool ContractAttachment::has_contracttype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ContractAttachment::set_has_contracttype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ContractAttachment::clear_has_contracttype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ContractAttachment::clear_contracttype() {
  if (contracttype_ != &::google::protobuf::internal::kEmptyString) {
    contracttype_->clear();
  }
  clear_has_contracttype();
}
inline const ::std::string& ContractAttachment::contracttype() const {
  return *contracttype_;
}
inline void ContractAttachment::set_contracttype(const ::std::string& value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
}
inline void ContractAttachment::set_contracttype(const char* value) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(value);
}
inline void ContractAttachment::set_contracttype(const char* value, size_t size) {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  contracttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContractAttachment::mutable_contracttype() {
  set_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    contracttype_ = new ::std::string;
  }
  return contracttype_;
}
inline ::std::string* ContractAttachment::release_contracttype() {
  clear_has_contracttype();
  if (contracttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contracttype_;
    contracttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContractAttachment::set_allocated_contracttype(::std::string* contracttype) {
  if (contracttype_ != &::google::protobuf::internal::kEmptyString) {
    delete contracttype_;
  }
  if (contracttype) {
    set_has_contracttype();
    contracttype_ = contracttype;
  } else {
    clear_has_contracttype();
    contracttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 11 [default = false];
inline bool ContractAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ContractAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ContractAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ContractAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool ContractAttachment::needreceipt() const {
  return needreceipt_;
}
inline void ContractAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// Torg13Attachment

// required .SignedContent SignedContent = 1;
inline bool Torg13Attachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Torg13Attachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Torg13Attachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Torg13Attachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::SignedContent& Torg13Attachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::SignedContent* Torg13Attachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::SignedContent;
  return signedcontent_;
}
inline ::SignedContent* Torg13Attachment::release_signedcontent() {
  clear_has_signedcontent();
  ::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void Torg13Attachment::set_allocated_signedcontent(::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool Torg13Attachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Torg13Attachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Torg13Attachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Torg13Attachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Torg13Attachment::filename() const {
  return *filename_;
}
inline void Torg13Attachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Torg13Attachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Torg13Attachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* Torg13Attachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool Torg13Attachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Torg13Attachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Torg13Attachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Torg13Attachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Torg13Attachment::comment() const {
  return *comment_;
}
inline void Torg13Attachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Torg13Attachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Torg13Attachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* Torg13Attachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DocumentId InitialDocumentIds = 4;
inline int Torg13Attachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void Torg13Attachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::DocumentId& Torg13Attachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::DocumentId* Torg13Attachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::DocumentId* Torg13Attachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
Torg13Attachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
Torg13Attachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .DocumentId SubordinateDocumentIds = 5;
inline int Torg13Attachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void Torg13Attachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::DocumentId& Torg13Attachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::DocumentId* Torg13Attachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::DocumentId* Torg13Attachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
Torg13Attachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
Torg13Attachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// required string DocumentDate = 6;
inline bool Torg13Attachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Torg13Attachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Torg13Attachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Torg13Attachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& Torg13Attachment::documentdate() const {
  return *documentdate_;
}
inline void Torg13Attachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void Torg13Attachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void Torg13Attachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* Torg13Attachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DocumentNumber = 7;
inline bool Torg13Attachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Torg13Attachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Torg13Attachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Torg13Attachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& Torg13Attachment::documentnumber() const {
  return *documentnumber_;
}
inline void Torg13Attachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void Torg13Attachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void Torg13Attachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* Torg13Attachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Total = 8;
inline bool Torg13Attachment::has_total() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Torg13Attachment::set_has_total() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Torg13Attachment::clear_has_total() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Torg13Attachment::clear_total() {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    total_->clear();
  }
  clear_has_total();
}
inline const ::std::string& Torg13Attachment::total() const {
  return *total_;
}
inline void Torg13Attachment::set_total(const ::std::string& value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void Torg13Attachment::set_total(const char* value) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(value);
}
inline void Torg13Attachment::set_total(const char* value, size_t size) {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  total_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_total() {
  set_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    total_ = new ::std::string;
  }
  return total_;
}
inline ::std::string* Torg13Attachment::release_total() {
  clear_has_total();
  if (total_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_;
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_total(::std::string* total) {
  if (total_ != &::google::protobuf::internal::kEmptyString) {
    delete total_;
  }
  if (total) {
    set_has_total();
    total_ = total;
  } else {
    clear_has_total();
    total_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string CustomDocumentId = 9;
inline bool Torg13Attachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Torg13Attachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Torg13Attachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Torg13Attachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& Torg13Attachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void Torg13Attachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void Torg13Attachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void Torg13Attachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* Torg13Attachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Grounds = 10;
inline bool Torg13Attachment::has_grounds() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Torg13Attachment::set_has_grounds() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Torg13Attachment::clear_has_grounds() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Torg13Attachment::clear_grounds() {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    grounds_->clear();
  }
  clear_has_grounds();
}
inline const ::std::string& Torg13Attachment::grounds() const {
  return *grounds_;
}
inline void Torg13Attachment::set_grounds(const ::std::string& value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void Torg13Attachment::set_grounds(const char* value) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(value);
}
inline void Torg13Attachment::set_grounds(const char* value, size_t size) {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  grounds_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Torg13Attachment::mutable_grounds() {
  set_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    grounds_ = new ::std::string;
  }
  return grounds_;
}
inline ::std::string* Torg13Attachment::release_grounds() {
  clear_has_grounds();
  if (grounds_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grounds_;
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Torg13Attachment::set_allocated_grounds(::std::string* grounds) {
  if (grounds_ != &::google::protobuf::internal::kEmptyString) {
    delete grounds_;
  }
  if (grounds) {
    set_has_grounds();
    grounds_ = grounds;
  } else {
    clear_has_grounds();
    grounds_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 11 [default = false];
inline bool Torg13Attachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Torg13Attachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Torg13Attachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Torg13Attachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool Torg13Attachment::needreceipt() const {
  return needreceipt_;
}
inline void Torg13Attachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// ServiceDetailsAttachment

// required .SignedContent SignedContent = 1;
inline bool ServiceDetailsAttachment::has_signedcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceDetailsAttachment::set_has_signedcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceDetailsAttachment::clear_has_signedcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceDetailsAttachment::clear_signedcontent() {
  if (signedcontent_ != NULL) signedcontent_->::SignedContent::Clear();
  clear_has_signedcontent();
}
inline const ::SignedContent& ServiceDetailsAttachment::signedcontent() const {
  return signedcontent_ != NULL ? *signedcontent_ : *default_instance_->signedcontent_;
}
inline ::SignedContent* ServiceDetailsAttachment::mutable_signedcontent() {
  set_has_signedcontent();
  if (signedcontent_ == NULL) signedcontent_ = new ::SignedContent;
  return signedcontent_;
}
inline ::SignedContent* ServiceDetailsAttachment::release_signedcontent() {
  clear_has_signedcontent();
  ::SignedContent* temp = signedcontent_;
  signedcontent_ = NULL;
  return temp;
}
inline void ServiceDetailsAttachment::set_allocated_signedcontent(::SignedContent* signedcontent) {
  delete signedcontent_;
  signedcontent_ = signedcontent;
  if (signedcontent) {
    set_has_signedcontent();
  } else {
    clear_has_signedcontent();
  }
}

// required string FileName = 2;
inline bool ServiceDetailsAttachment::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceDetailsAttachment::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceDetailsAttachment::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceDetailsAttachment::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ServiceDetailsAttachment::filename() const {
  return *filename_;
}
inline void ServiceDetailsAttachment::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ServiceDetailsAttachment::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ServiceDetailsAttachment::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDetailsAttachment::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ServiceDetailsAttachment::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceDetailsAttachment::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Comment = 3;
inline bool ServiceDetailsAttachment::has_comment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceDetailsAttachment::set_has_comment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceDetailsAttachment::clear_has_comment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceDetailsAttachment::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ServiceDetailsAttachment::comment() const {
  return *comment_;
}
inline void ServiceDetailsAttachment::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ServiceDetailsAttachment::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ServiceDetailsAttachment::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDetailsAttachment::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ServiceDetailsAttachment::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceDetailsAttachment::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DocumentId InitialDocumentIds = 4;
inline int ServiceDetailsAttachment::initialdocumentids_size() const {
  return initialdocumentids_.size();
}
inline void ServiceDetailsAttachment::clear_initialdocumentids() {
  initialdocumentids_.Clear();
}
inline const ::DocumentId& ServiceDetailsAttachment::initialdocumentids(int index) const {
  return initialdocumentids_.Get(index);
}
inline ::DocumentId* ServiceDetailsAttachment::mutable_initialdocumentids(int index) {
  return initialdocumentids_.Mutable(index);
}
inline ::DocumentId* ServiceDetailsAttachment::add_initialdocumentids() {
  return initialdocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
ServiceDetailsAttachment::initialdocumentids() const {
  return initialdocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
ServiceDetailsAttachment::mutable_initialdocumentids() {
  return &initialdocumentids_;
}

// repeated .DocumentId SubordinateDocumentIds = 5;
inline int ServiceDetailsAttachment::subordinatedocumentids_size() const {
  return subordinatedocumentids_.size();
}
inline void ServiceDetailsAttachment::clear_subordinatedocumentids() {
  subordinatedocumentids_.Clear();
}
inline const ::DocumentId& ServiceDetailsAttachment::subordinatedocumentids(int index) const {
  return subordinatedocumentids_.Get(index);
}
inline ::DocumentId* ServiceDetailsAttachment::mutable_subordinatedocumentids(int index) {
  return subordinatedocumentids_.Mutable(index);
}
inline ::DocumentId* ServiceDetailsAttachment::add_subordinatedocumentids() {
  return subordinatedocumentids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DocumentId >&
ServiceDetailsAttachment::subordinatedocumentids() const {
  return subordinatedocumentids_;
}
inline ::google::protobuf::RepeatedPtrField< ::DocumentId >*
ServiceDetailsAttachment::mutable_subordinatedocumentids() {
  return &subordinatedocumentids_;
}

// optional string CustomDocumentId = 6;
inline bool ServiceDetailsAttachment::has_customdocumentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceDetailsAttachment::set_has_customdocumentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceDetailsAttachment::clear_has_customdocumentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceDetailsAttachment::clear_customdocumentid() {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    customdocumentid_->clear();
  }
  clear_has_customdocumentid();
}
inline const ::std::string& ServiceDetailsAttachment::customdocumentid() const {
  return *customdocumentid_;
}
inline void ServiceDetailsAttachment::set_customdocumentid(const ::std::string& value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ServiceDetailsAttachment::set_customdocumentid(const char* value) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(value);
}
inline void ServiceDetailsAttachment::set_customdocumentid(const char* value, size_t size) {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  customdocumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDetailsAttachment::mutable_customdocumentid() {
  set_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    customdocumentid_ = new ::std::string;
  }
  return customdocumentid_;
}
inline ::std::string* ServiceDetailsAttachment::release_customdocumentid() {
  clear_has_customdocumentid();
  if (customdocumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdocumentid_;
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceDetailsAttachment::set_allocated_customdocumentid(::std::string* customdocumentid) {
  if (customdocumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete customdocumentid_;
  }
  if (customdocumentid) {
    set_has_customdocumentid();
    customdocumentid_ = customdocumentid;
  } else {
    clear_has_customdocumentid();
    customdocumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DocumentDate = 7;
inline bool ServiceDetailsAttachment::has_documentdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServiceDetailsAttachment::set_has_documentdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServiceDetailsAttachment::clear_has_documentdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServiceDetailsAttachment::clear_documentdate() {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    documentdate_->clear();
  }
  clear_has_documentdate();
}
inline const ::std::string& ServiceDetailsAttachment::documentdate() const {
  return *documentdate_;
}
inline void ServiceDetailsAttachment::set_documentdate(const ::std::string& value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ServiceDetailsAttachment::set_documentdate(const char* value) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(value);
}
inline void ServiceDetailsAttachment::set_documentdate(const char* value, size_t size) {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  documentdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDetailsAttachment::mutable_documentdate() {
  set_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    documentdate_ = new ::std::string;
  }
  return documentdate_;
}
inline ::std::string* ServiceDetailsAttachment::release_documentdate() {
  clear_has_documentdate();
  if (documentdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentdate_;
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceDetailsAttachment::set_allocated_documentdate(::std::string* documentdate) {
  if (documentdate_ != &::google::protobuf::internal::kEmptyString) {
    delete documentdate_;
  }
  if (documentdate) {
    set_has_documentdate();
    documentdate_ = documentdate;
  } else {
    clear_has_documentdate();
    documentdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DocumentNumber = 8;
inline bool ServiceDetailsAttachment::has_documentnumber() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServiceDetailsAttachment::set_has_documentnumber() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServiceDetailsAttachment::clear_has_documentnumber() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServiceDetailsAttachment::clear_documentnumber() {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    documentnumber_->clear();
  }
  clear_has_documentnumber();
}
inline const ::std::string& ServiceDetailsAttachment::documentnumber() const {
  return *documentnumber_;
}
inline void ServiceDetailsAttachment::set_documentnumber(const ::std::string& value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ServiceDetailsAttachment::set_documentnumber(const char* value) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(value);
}
inline void ServiceDetailsAttachment::set_documentnumber(const char* value, size_t size) {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  documentnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDetailsAttachment::mutable_documentnumber() {
  set_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    documentnumber_ = new ::std::string;
  }
  return documentnumber_;
}
inline ::std::string* ServiceDetailsAttachment::release_documentnumber() {
  clear_has_documentnumber();
  if (documentnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = documentnumber_;
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServiceDetailsAttachment::set_allocated_documentnumber(::std::string* documentnumber) {
  if (documentnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete documentnumber_;
  }
  if (documentnumber) {
    set_has_documentnumber();
    documentnumber_ = documentnumber;
  } else {
    clear_has_documentnumber();
    documentnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool NeedReceipt = 9 [default = false];
inline bool ServiceDetailsAttachment::has_needreceipt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServiceDetailsAttachment::set_has_needreceipt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServiceDetailsAttachment::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServiceDetailsAttachment::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool ServiceDetailsAttachment::needreceipt() const {
  return needreceipt_;
}
inline void ServiceDetailsAttachment::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// -------------------------------------------------------------------

// DocumentId

// required string MessageId = 1;
inline bool DocumentId::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentId::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentId::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentId::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& DocumentId::messageid() const {
  return *messageid_;
}
inline void DocumentId::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void DocumentId::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void DocumentId::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentId::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* DocumentId::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DocumentId::set_allocated_messageid(::std::string* messageid) {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    delete messageid_;
  }
  if (messageid) {
    set_has_messageid();
    messageid_ = messageid;
  } else {
    clear_has_messageid();
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string EntityId = 2;
inline bool DocumentId::has_entityid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentId::set_has_entityid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentId::clear_has_entityid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentId::clear_entityid() {
  if (entityid_ != &::google::protobuf::internal::kEmptyString) {
    entityid_->clear();
  }
  clear_has_entityid();
}
inline const ::std::string& DocumentId::entityid() const {
  return *entityid_;
}
inline void DocumentId::set_entityid(const ::std::string& value) {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  entityid_->assign(value);
}
inline void DocumentId::set_entityid(const char* value) {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  entityid_->assign(value);
}
inline void DocumentId::set_entityid(const char* value, size_t size) {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  entityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DocumentId::mutable_entityid() {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  return entityid_;
}
inline ::std::string* DocumentId::release_entityid() {
  clear_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entityid_;
    entityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DocumentId::set_allocated_entityid(::std::string* entityid) {
  if (entityid_ != &::google::protobuf::internal::kEmptyString) {
    delete entityid_;
  }
  if (entityid) {
    set_has_entityid();
    entityid_ = entityid;
  } else {
    clear_has_entityid();
    entityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MessageToPost_2eproto__INCLUDED
